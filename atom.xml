<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimY Blog</title>
  
  <subtitle>穷则变 变则通 通则久</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://MBTimY.github.io/"/>
  <updated>2017-11-30T19:40:31.000Z</updated>
  <id>http://MBTimY.github.io/</id>
  
  <author>
    <name>TimY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Nginx在Ubuntu搭建反向代理</title>
    <link href="http://MBTimY.github.io/2017/11/30/ReverseProxyWithNginx/"/>
    <id>http://MBTimY.github.io/2017/11/30/ReverseProxyWithNginx/</id>
    <published>2017-11-30T10:54:34.000Z</published>
    <updated>2017-11-30T19:40:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h3><p>最近受朋友的要求帮他做一个反向代理，在过程之中遇到一些问题我觉得可以通过编写一个文章来记录整个搭建的过程供自己以后参考使用</p><h3 id="何为反向代理"><a href="#何为反向代理" class="headerlink" title="何为反向代理"></a>何为反向代理</h3><blockquote><p>在电脑网络中，反向代理是代理服务器的一种。它根据客户端的请求，从后端的服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端[1]。与前向代理不同，前向代理作为一个媒介将互联网上获取的资源返回给相关联的客户端，而反向代理是在服务器端（如Web服务器）作为代理使用，而不是客户端。客户端通过前向代理可以访问很多不同的资源，而反向代理是很多客户端都通过它访问不同后端服务器上的资源，而不需要知道这些后端服务器的存在，而以为所有资源都来自于这个反向代理服务器。</p></blockquote><h3 id="搭建反响代理用于访问一些被屏蔽的网站"><a href="#搭建反响代理用于访问一些被屏蔽的网站" class="headerlink" title="搭建反响代理用于访问一些被屏蔽的网站"></a>搭建反响代理用于访问一些被屏蔽的网站</h3><p>上面的解释是比较正式的讲解，在我这次的任务中用到的主要是反向代理可以让用户可以透明访问到一些无法访问到的后端服务器的特性。</p><p>因为这个特性可以使得用户可以访问一些在一些特殊地区无法正常访问道的资源，提供一些便利。</p><p>下面正式来记录搭建整个反向代理的过程：</p><ul><li>准备一台任意发行版的linux服务器（当然windows也是可以的但是一般我比较少使用），这里我们使用一台Ubuntu。</li><li><p>在Ubuntu主机中使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$cd ~/</div><div class="line">$wget http://nginx.org/download/nginx-1.2.8.tar.gz  // 指定版本在线安装</div><div class="line">$tar -zxvf nginx-1.2.8.tar.gz //解压缩</div><div class="line">$sudo apt-get install libpcre3 libpcre3-dev zlib1g-dev libssl-dev //安装依赖库</div></pre></td></tr></table></figure></li><li><p>按照上面的指令把nginx已经正常的解压到特定目录，并且把nginx安装中所必需的依赖库也安装到机器中以后我们紧接下面的步骤来继续</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#git clone git://github.com/yaoweibin/ngx_http_substitutions_filter_module.git</div><div class="line">#cd nginx-1.2.8</div><div class="line">#useradd -r nginx</div><div class="line">#./configure --prefix=/usr/local/nginx \</div><div class="line">--user=nginx \</div><div class="line">--group=nginx \</div><div class="line">--with-http_gzip_static_module \</div><div class="line">--with-http_ssl_module \</div><div class="line">--with-http_stub_status_module \</div><div class="line">--add-module=../ngx_http_substitutions_filter_module</div><div class="line">#make install</div></pre></td></tr></table></figure></li><li><p>通过上面的步骤nginx和ngx_http_substitutions_filter_module这个模块已经正常的安装到主机上面，然后继续配置位于/usr/local/conf/nginx.conf的文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">  server_name example.com;</div><div class="line">  listen 80;</div><div class="line">  </div><div class="line">  location / &#123;</div><div class="line">    proxy_pass 想要反向代理的网站地址;</div><div class="line">    proxy_buffering off;</div><div class="line"></div><div class="line">    proxy_cookie_domain target.com example.com;</div><div class="line">    proxy_redirect target.com /;</div><div class="line"></div><div class="line">    proxy_set_header X-Real_IP $remote_addr;</div><div class="line">    proxy_set_header User-Agent $http_user_agent;</div><div class="line">    proxy_set_header Accept-Encoding &apos;&apos;;</div><div class="line">    proxy_set_header referer &quot;http://target.com$request_uri&quot;;</div><div class="line"></div><div class="line">    subs_filter_types text/css text/xml text/javascript;</div><div class="line">    subs_filter example.com target.com</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>以上的配置可以反向代理一个特定的网站（注意server这个上下文里面的选项必须要包含在配置文件中http上下文中），使用户可以通过我们自己的服务器来访问一个特定的后端，上面的 <code>subs_filter_types subs_filter</code>可以用于替换后端返回的应答消息中的特定字符串起到一些替换链接地址或者某些关键自字符的作用。</li></ul><p><em>其他的相关nginx选项所代表的意思可以在下面给出的参考中获取。</em></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass" target="_blank" rel="external">NginxProxyModule</a>   包含了NginxProxy模块的所有选项</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题记&quot;&gt;&lt;a href=&quot;#题记&quot; class=&quot;headerlink&quot; title=&quot;题记&quot;&gt;&lt;/a&gt;题记&lt;/h3&gt;&lt;p&gt;最近受朋友的要求帮他做一个反向代理，在过程之中遇到一些问题我觉得可以通过编写一个文章来记录整个搭建的过程供自己以后参考使用&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://MBTimY.github.io/tags/Nginx/"/>
    
      <category term="RProxy" scheme="http://MBTimY.github.io/tags/RProxy/"/>
    
  </entry>
  
  <entry>
    <title>Android程序分析实例记录</title>
    <link href="http://MBTimY.github.io/2017/10/17/analysisofrrmj/"/>
    <id>http://MBTimY.github.io/2017/10/17/analysisofrrmj/</id>
    <published>2017-10-16T21:34:50.000Z</published>
    <updated>2017-10-19T19:12:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为入坑Android逆向的第一个APP，我觉得需要为了它专门写一篇文章来记录一下整个过程作为纪念。看本篇文章需要有一定的APK打包知识、JAVA知识、IDAPro的使用经验。</p><p>这个APP我主要的目的是获取到此APP中的一个调用外部native代码的函数，函数存放在一个.so文件中。这个函数主要的目的是用做一个特殊连接的认证，只有通过了这套认证机制以后发出去的网络请求才能得到正常的相应结果，其中如何定位到这个.so文件；怎么找到这个函数就是一个native代码；如何通过修改程序的请求信息可以正常获取等细节在本文章中不详细的赘述可以在参考中查看专门介绍这部分的文章。</p><h2 id="确立目标与收集信息"><a href="#确立目标与收集信息" class="headerlink" title="确立目标与收集信息"></a>确立目标与收集信息</h2><p><strong>本次逆向的目标</strong>：找出本次APP中一个功能请求，该功能请求可以获取到远端服务器特殊资源。</p><p>目标的确立是逆向分析的重中之重的一项，明确清晰的目标可以让我们接下来的工作条理清晰不至于迷失在大量的代码中。</p><p><strong>反汇编代码</strong>：为了找出该功能请求部分的代码，我们第一步需要把应用程序的APK文件解包获取到他的smali文件和一些资源文件等，这里所用到的工具是<code>apktool</code>利用下面的命令我们可以将apk文件完整的解包到一个指定的目录中：</p><blockquote><p>java -jar apktool.jar d xxx.apk -o /xxx </p></blockquote><p><strong> 在我们本篇文章中的例子，我解压出来的代码包含了如下的文件和目录：</strong></p><pre><code>-rw-r--r--    1 ooxx  staff    47K 10 14 01:31 AndroidManifest.xml-rw-r--r--    1 ooxx  staff    19K 10 14 01:31 apktool.ymldrwxr-xr-x   28 ooxx  staff   952B 10 14 01:31 assetsdrwxr-xr-x    3 ooxx  staff   102B 10 14 01:33 builddrwxr-xr-x    5 ooxx  staff   170B 10 14 03:58 libdrwxr-xr-x    4 ooxx  staff   136B 10 14 01:31 originaldrwxr-xr-x  142 ooxx  staff   4.7K 10 14 01:31 resdrwxr-xr-x   17 ooxx  staff   578B 10 14 01:31 smalidrwxr-xr-x   16 ooxx  staff   544B 10 14 01:31 smali_classes2drwxr-xr-x    4 ooxx  staff   136B 10 14 01:31 unknown</code></pre><p>基本上所有的APK文件解包出来都包含了上面的这些文件和目录，samli*这样的目录会根据APK文件中.dex文件的多少有所增减,其他的目录相关的解释说明可以在我文章中后贴出的参考中去寻找这里不赘述这些基本概念。</p><p>这些文件中我为了找出与我的目标相关的代码需要关注的主要有<code>smali smali_classes2 lib AndroidManifest.xml</code> 这几个文件和目录，具体的使用此处先按下不表下面会说到的。我们现在通过了工具解包得到了这个包含了大量文件目录，但是直接通过smali格式来查看代码并不是特别的方便，这里我为了阅读代码的良好体验使用了<code>jdax</code>来可视化的得到我们整个APK的整个结构，并且这个工具反编译出来的.dex文件不是smali的形式而是转换成Java代码方便我们阅读。</p><p>上面的步骤中我们得到了APK文件中的smali和Java形式的代码，完整的查看这个APK中的流程和一些常量、函数、资源ID等等都不再是问题。按照我分析程序的习惯是先浏览一下代码的结构，在直觉上面感受了一下这款程序中包含的一些函数和库的名称是否有熟悉的或者是否是引用一些公开的库，并且找到程序主要逻辑部分的代码缩小分析的范围。对于Android程序，要做到这点要更加简单因为我们通过阅读<code>AndroidManifest.xml</code>这个文件获取到主要逻辑的包名，快速的找到存放程序主要逻辑的代码部分。</p><h2 id="定位关键代码"><a href="#定位关键代码" class="headerlink" title="定位关键代码"></a>定位关键代码</h2><p>上一节的信息收集在我本次分析的APP中进行的很顺利，主要是因为该APP没有进行一些强力的加固措施通过工具我们就把它各种数据展示出来了，如果在信息收集的过程中遇见的程序进行一些比较强力的加固措施，那上一节的过程消耗的时间将会根据加密软件的强度呈几何数据的上升。</p><p>接下来根据上一节明确好的目标，可以通过APP在模拟器或者真实机器上面的使用来获得一些额外的信息来帮助我们找到与目标相关的代码，这些信息可以是：界面上面的关键字、触发行为以后的网络封包、一些提示信息等等我们ł以通过直观的观察得到的东西。针对这里的APP我们的目标是找到一个网络请求的功能，我这里利用的是<code>wireshark</code> 来抓取通过模拟器触发我关注的那个功能行为时的封包情况，具体的操作非常的简单：打开<code>wireshark</code> 然后选中Android模拟器模拟的网卡设备，然后在模拟器中点击所需要关注的那个功能按钮后查看<code>wireshark</code> 的封包界面就可以找到相关的数据封包了，在实际的操作中如果封包过多可以使用软件的filter过滤一下封包避免太多无关的数据干扰。透过观察封包发现此处我需要分析的APP采用了SSL作为数据传输的协议导致无法从封包中直接获取到我想要的数据，此时虽然无法得到数据部分的东西了不过通过SSL中第一个客户端发往服务端的ClientHello信息至少可以得到服务端的域名地址。</p><p>得到这个关键的域名地址信息以后，在<code>jdax</code>中使用搜索功能找到有关与这个域名相关的代码部分进行分析找出我们需要关心的那部分代码，这里我找到的是一个用于存放整个程序所用到的链接的一个类，该类会在程序初始化的时候被执行得到一个包含程序几乎所有所能用到链接的对象，这个对象会用在很多与网络请求相关的地方通过分析该对象的引用我们可以缩小查找的范围，由于<code>jdax</code> 没有查找交叉引用的功能我们找到引用的方法还是利用它自带的搜索功能来实现。</p><p>上面的操作把所需要分析的代码的范围进行了非常大的缩减精确定位到了少量的代码来供我们查阅，如果此时面q对的不是android程序走到这一部分剩下的工作就是靠经验和自己做一些自动化的工具再在一些细节上面去寻找蛛丝马迹来定位到关键代码了，不过在Android程序中我们有<code>AndroidManifest.xml</code> 这个文件透过它可以大大的加速这整个追寻的过程具体的方法我讲一种简单的：在APP中先切换到我们关注的那部分功能的界面；在这个界面中找一些关键字在<code>jdax</code>中搜索；找到包含这些字符串的activity后去<code>AndroidManifest.xml</code>文件中找到具体的位置；查看一下这些activity的名称、布局之间有没有什么有价值的线索，分析一些直觉上面觉得可疑的函数来锁定位置。</p><p>上面的讲述中有关于<strong>直觉</strong>的那部分基本上来说是取决一个经验的问题，如果要铺开这方面知识来说基本上可以出一两本书了，我这里简单说一下我的理解：对于逆向分析人员来说直觉也是可以量化的一种产物，通常来说在针对一些经常出现的情况我们会将自己的工作经验使用一些自动化编程来简化未来出现同样情况下的工作，有些自动化编程上面难以实现的我们才继续保留使用手动的方式来处理，由于上述的工作经验完全取决分析程序的多寡和对于不同的程序原理的理解上所花费的时间，这里我只能简单说在一经按照上述的简单流程之后缩减了查找范围，最后就是通过自己的逆向经验来找寻最后的那部分关键代码了。</p><h2 id="抓住重点分析关键函数"><a href="#抓住重点分析关键函数" class="headerlink" title="抓住重点分析关键函数"></a>抓住重点分析关键函数</h2><p>来到这一步我已经找到了关注的功能的关键代码的实现部分，这里的工作没有什么很固定话的流程因为基本上来说是考验我们基本功：对于所逆向的程序的代码的理解；对于一些引用的公有库的使用上面的熟悉程度；不断的通过资料来理解那些不懂的逻辑部分等。在本次分析的APP中我最终找到了一个对于一个外部.so文件的一个函数的引用，在Android里面一般称这种调用叫做native代码的调用采用的方法一般是JNI。</p><p>得到了上面的准确的信息，下面的步骤就是如何找出JNI调用的函数来供我们分析。这里用到的知识就是如果用IDAPRO进行native代码的动态调试，具体的相关操作我会在文章最后的参考中给出一些不错的文章来参考。这里简单的说一下结果：通过利用IDAPRO对该程序进行动态调试以后，发现调用的native代码没有被混淆或者加密但是有一个关键函数会对程序的签名进行校验，如果得到程序的校验值与预设的数值不一致的话会使得程序发现自己的程序被重新打包安装了，那么这个函数会把一个传递给服务端的加密字符串改成错误的字符串导致服务端认证客户端失败而不会发送正常的数据给客户端。过掉这层校验以后继续追踪可以到我需要的那段函数里面，在IDAPRO里面可以使用强大的F5功能将代码完全的抽离出来转义成别的语言来实现相同的功能，将转义的函数配合<code>jdax</code>处反编译的java代码可以完整的写出一个脱机函数来实现第三方的完整调用，在整个抽离函数的过程中可能IDAPRO的F5功能有些地方处理的不是特别的好，我们对于部分代码可能还是需要人为的分析ARM指令才能得到更好的结果。</p><p>自此整个目标达成，使得我自己可以写一个模拟程序来模拟整个网络请求包并且得到正常的服务器响应。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/ba9b374346dd" target="_blank" rel="external">Android逆向之smali语法宝典</a></p><p><a href="https://blog.bramp.net/post/2015/08/01/decompile-and-recompile-android-apk/" target="_blank" rel="external">Decompile and Recompile Android APK</a></p><p><a href="http://www.cnblogs.com/bastard/archive/2012/05/19/2508913.html" target="_blank" rel="external">Android中JNI的使用方法</a></p><p><a href="https://dev.qq.com/topic/59190e40e315487c53deec9f" target="_blank" rel="external">手把手教你逆向分析 Android 程序</a></p><p><a href="http://www.cnblogs.com/gordon0918/p/5581597.html" target="_blank" rel="external">android调试系列–使用ida pro调试原生程序</a></p><p><a href="http://rootkiter.com/2015/08/05/ARM%E6%8C%87%E4%BB%A4%E7%BB%93%E6%9E%84%E5%92%8Ccrack%E6%80%9D%E8%B7%AF.html" target="_blank" rel="external">ARM指令结构和crack思路</a></p><p><a href="https://zhuanlan.zhihu.com/p/28269402" target="_blank" rel="external">闲扯ARM指令集一</a></p><p><a href="http://infocenter.arm.com/help/index.jsp" target="_blank" rel="external">ARM 帮助页面</a></p><p><a href="http://www.10tiao.com/html/523/201708/2458284945/1.html" target="_blank" rel="external">ARM汇编基础教程——ARM指令集</a></p><p><a href="http://www.10tiao.com/html/523/201708/2458284827/1.html" target="_blank" rel="external">物联网中的 ARM 漏洞利用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;作为入坑Android逆向的第一个APP，我觉得需要为了它专门写一篇文章来记录一下整个过程作为纪念。看本篇文章需要有一定的APK打包知识、J
      
    
    </summary>
    
    
      <category term="hack" scheme="http://MBTimY.github.io/tags/hack/"/>
    
      <category term="binary" scheme="http://MBTimY.github.io/tags/binary/"/>
    
      <category term="android" scheme="http://MBTimY.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android调试逆向分析环境搭建汇总</title>
    <link href="http://MBTimY.github.io/2017/10/15/androidreverseenv/"/>
    <id>http://MBTimY.github.io/2017/10/15/androidreverseenv/</id>
    <published>2017-10-15T15:10:49.000Z</published>
    <updated>2017-10-16T21:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无意之间入坑到Android的一项调试工作中，感觉要分析+动态调试android在搭建环境上比较麻烦，特此在这里记录一些搭建中遇到的问题和流程。</p><h2 id="Android基本环境搭建"><a href="#Android基本环境搭建" class="headerlink" title="Android基本环境搭建"></a>Android基本环境搭建</h2><h3 id="AndroidStudio工具"><a href="#AndroidStudio工具" class="headerlink" title="AndroidStudio工具"></a>AndroidStudio工具</h3><p>从<a href="https://developer.android.com/studio/index.html?hl=zh-cn" target="_blank" rel="external">AndroidStudio安装地址</a>下载AndroidStudio这个Android开发的新宠，现在它已经取代了Eclipse。首先下载它的主要原因，是在调试过程中要使用到<code>adb zipalign jarsigner keytool ...</code>的这些工具，都需要通过下载它来获取。<br>通过它还可以进行针对源码级别的调试，当然这里的源码指的是将.dex文件利用<code>baksmali.jar</code>反编译成出来的smali文件。</p><p>对于上述的smali文件，简单来说可以概述成：Java程序可以运行在各种符合Java规范的虚拟机中；Android中用于运行Java程序（直觉上面来说可以这么理解）的是Dalvik这个由google等厂商合作开发的虚拟机，此虚拟机由于要适应内存和CPU处理有限的场景作出了很多优化。对于处理的Java程序格式也不是采用传统的JVM方式，而是自己专门设计的一套叫做.dex(“Dalvik Executable“)的压缩格式，所以在Android程序打包阶段最重要的一步，是将我们编写的java代码和其他的一些额外信息一起打包成.dex格式以供后面的执行；<br>smali是一种可读格式，通过<code>baksmali.jar</code>工具我们可以将保存在.dex格式中bytecode转换成smali这种可读格式，并保存在以不同的名称为标示的smali文件中以供我们阅读和修改的便利。</p><p>有了上面对于smali文件的理解，应该可以很好的理解为什么我会说这是一种源码级别的调试了，因为.dex保存的字节码通过反编译成smali文件以后拥有良好的阅读性（当然你得先熟悉smali这种格式）。对于具体调试的方法，下面的参考中我会列举一些不错的文章参考。</p><h3 id="Android逆向反编译工具"><a href="#Android逆向反编译工具" class="headerlink" title="Android逆向反编译工具"></a>Android逆向反编译工具</h3><p>此类工具目前在市面上种类繁多，虽然围绕着一个反编译的主题但却百花齐放，针对不同的角度来处理我们的.apk文件。</p><p>这里我提一下<a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">apktool</a>这款集中了很多功能的工具，简单的处理一个Android应用：解包、反编译、重新打包成.apk格式。这些任务只需要这一款工具就可以很好的实现了，在实际处理中这个工具的使用率非常之高，唯一的缺陷也只是由于这个工具是一个集合了各类工具的集合包，所以针对它所集合的工具比如：将.dex文件反编译成smali文件的<code>baksmali.jar</code>的更新上面可能跟不上这些工具的主版本，所以当在使用apktool的某些功能出现什么错误的时候，需要看一下这些被集成进来的工具是否已经处理了这些既有的错误。<br>更多更全面的工具包下载，我找到了一个不错的网站记录的非常详细：<a href="http://www.androiddevtools.cn/" target="_blank" rel="external">androiddevtools</a></p><p>下面记录几个不错的工具的名称和描述：</p><h4 id="enjarify"><a href="#enjarify" class="headerlink" title="enjarify"></a>enjarify</h4><p><a href="https://github.com/google/enjarify" target="_blank" rel="external">https://github.com/google/enjarify</a>这个工具是谷歌官方开源的用于反编译dex文件的。使用方法和dex2jar差不多，也是简单的命令行操作。这个工具的主页中也提到dex2jar已经是一个比较老的工具，在遇到混淆等等复杂的情况时，可能无法正常工作。所以这里推荐大家使用enjarify这个工具。</p><h4 id="jd-gui"><a href="#jd-gui" class="headerlink" title="jd-gui"></a>jd-gui</h4><p><a href="http://jd.benow.ca/" target="_blank" rel="external">http://jd.benow.ca/</a> 这个工具不用多说，用于查看jar文件中的java代码。</p><h4 id="android-classyshark"><a href="#android-classyshark" class="headerlink" title="android-classyshark"></a>android-classyshark</h4><p><a href="https://github.com/google/android-classyshark/releases" target="_blank" rel="external">https://github.com/google/android-classyshark/releases</a>带有界面，一键反编译Apk工具，直接打开Apk文件，就可以看到Apk中所有的文件结构，甚至还集成了dex文件查看，java代码查看，方法数分析、导入混淆mapping文件等一系列工具。谷歌推出这个工具的目的是为了让我们开发者更清楚的了解自己的Apk中都有什么文件、混淆前后有什么变化，并方便我们进一步优化自己的Apk打包实现。</p><h4 id="AndroidGuard"><a href="#AndroidGuard" class="headerlink" title="AndroidGuard"></a>AndroidGuard</h4><p><a href="https://github.com/androguard/androguard/releases" target="_blank" rel="external">https://github.com/androguard/androguard/releases</a>集成了反编译资源、代码等各种文件的工具包。需要安装Python环境来运行这个工具，这个工具按照不同的反编译需求，分别写成了不同的py功能模块，还有静态分析的功能。所以如果想要用Python开发一个解析Apk文件并进行静态扫描分析的服务，可以引用这个工具来实现。这个工具基本来说属于高级应用里面才会用到，主要通过编写一些自动化工具来处理一些比较复杂的程序来获得我们想要的效果。</p><h4 id="Android-Crack-Tool"><a href="#Android-Crack-Tool" class="headerlink" title="Android-Crack-Tool"></a>Android-Crack-Tool</h4><p><a href="https://github.com/Jermic/Android-Crack-Tool" target="_blank" rel="external">https://github.com/Jermic/Android-Crack-Tool</a>这是网上一位名为Jermic的大神开发的、在Mac环境下使用的App，集成了Android开发中常见的一些编译/反编译工具，方便用户对Apk进行逆向分析，提供Apk信息查看功能。</p><h4 id="ApkParser"><a href="#ApkParser" class="headerlink" title="ApkParser"></a>ApkParser</h4><p><a href="https://github.com/jaredrummler/APKParser" target="_blank" rel="external">https://github.com/jaredrummler/APKParser</a>在电脑上已经有了这么多的工具，在手机上的也有很方便的工具。APKParser是一款在查看手机上已经安装的Apk的信息的工具，他可以查看软件的AndroidManifest.xml文件、方法数、res资源文件，并在手机上直接展示出来。</p><h4 id="Smalidea"><a href="#Smalidea" class="headerlink" title="Smalidea"></a>Smalidea</h4><p><a href="https://github.com/JesusFreke/smali/wiki/smalidea" target="_blank" rel="external">https://github.com/JesusFreke/smali/wiki/smalidea</a>smalidea是一个IntelliJ IDEA/Android Studio smali语言插件，可实现动态调试smali代码。对于想使用Android Studio来动态调试APK文件这个插件不可缺少。</p><h4 id="APKIDE"><a href="#APKIDE" class="headerlink" title="APKIDE"></a>APKIDE</h4><p><a href="https://www.52pojie.cn/thread-399571-1-1.html" target="_blank" rel="external">https://www.52pojie.cn/thread-399571-1-1.html</a> 一个集合了很多功能的一体式工具，可以通过它进行反编译、解包、重组、查看java代码等功能。这个工具目前只能在windows上面运行；大量的集合了现有的一些工具在里面；通过它可以为我们的逆向工作提供更大的便利性在windows平台上面，避免我们自己到处下载工具的劳累。</p><h3 id="IDAPRO逆向神器"><a href="#IDAPRO逆向神器" class="headerlink" title="IDAPRO逆向神器"></a>IDAPRO逆向神器</h3><p>最后提到了逆向神器IDAPRO，在逆向界应该无人不知无人不晓的东西。这个工具在Android的基础环境里面主要起到调试native代码的作用，配合上IDAPRO自带的<code>android_server</code>我们可以非常方便的调试Android调用在so文件中的native代码，对于阅读不友好的arm指令，IDAPRO的F5键绝对可以节约我们大量的时间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是总结一些Android调试前期需要搭建的环境和熟悉的工具，搭建好这样的环境是对后面的逆向工作良好的基础可以大大节约出我们的时间。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://unclechen.github.io/2016/09/07/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" target="_blank" rel="external">Android反编译技术总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;无意之间入坑到Android的一项调试工作中，感觉要分析+动态调试android在搭建环境上比较麻烦，特此在这里记录一些搭建中遇到的问题和流
      
    
    </summary>
    
    
      <category term="hack" scheme="http://MBTimY.github.io/tags/hack/"/>
    
      <category term="binary" scheme="http://MBTimY.github.io/tags/binary/"/>
    
      <category term="android" scheme="http://MBTimY.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>VMProtect 虚拟机检测弯路汇总</title>
    <link href="http://MBTimY.github.io/2017/10/01/vmpdetect/"/>
    <id>http://MBTimY.github.io/2017/10/01/vmpdetect/</id>
    <published>2017-09-30T18:55:23.000Z</published>
    <updated>2017-09-30T20:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章主要记录一下在处理 VMProtect 在WIN7系统中的虚拟机检测中, 走的一些弯路.避免老路重走的悲情…</p><h3 id="VMProtect-检测手段"><a href="#VMProtect-检测手段" class="headerlink" title="VMProtect 检测手段"></a>VMProtect 检测手段</h3><p>VMProtect3.X 以后增加的一个虚拟机检测手段比较棘手, 采用的技术是利用如下的 API 获取我们系统环境中的一些硬件相关的信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EnumSystemFirmwareTables</div><div class="line">GetSystemFirmwareTable</div></pre></td></tr></table></figure></p><p>上述的 API 函数简单来说拿来获取我们的 System Management BIOS(SMBIOS) 或者其他的存放在低于物理内存1MB 这个位置下面的一些 bios 数据,这里面的数据包含了我们系统中硬件相关的很多信息,其中当然就包含了我们这些该死硬件的厂商或者一些型号等等用于显示的字符串,然而我们的 VMware 很乐于告诉大家这些硬件都是我虚拟出来的,所以这些数据中包含了大量充斥着 VMware 标签的数据,这样数据被我们的 VMProtect 利用上成为了强有力的检测虚拟机的手段.</p><p>上述的两个API的功能是相辅相成的, 具体的使用看<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724379(v=vs.85).aspx" target="_blank" rel="external">点我看详情</a>, 这里简单的说一下用法.<br>第一步我们通过提交给 EnumSystemFirmwareTables 一个’FIRM’参数(如果在”小端”字节顺序下,在内存的显示可能会是” MRIF”), 函数会返回一个列表,这个列表是由于我们传入的是”FIRM”这个参数导致的,如果传入的是其他参数可能会返回其他的类型.<br>列表中包含了存放BIOS 数据的物理地址的起始地址,数据的大小是2M.下一步通过调用的GetSystemFirmwareTable函数来获取上述地址中的数据,这些数据就包含了我上面说到的各种 Vmware 相关字符串.</p><h3 id="Patch的尝试"><a href="#Patch的尝试" class="headerlink" title="Patch的尝试"></a>Patch的尝试</h3><p>知道了上述整个检测的过程以后, 比较简单的方法是通过编写一个插件或者脚本给调试器,Hook 掉上面的关键函数使函数无法正常获取到数据,然后再通过SharpOD 这个插件躲过 VMProtect 的调试器检测,就可以解决掉这个虚拟机检测的问题.</p><p>不死心的我觉得这样的方式不够优雅,这样的方式需要利用挂钩系统函数的方式.对于虚拟机检测这样的东西,当然最终极的方法是使得我们的虚拟机变成真机一样才是最优雅的,下面是一些尝试利用修改 VMware来解决,然后宣告失败的惨剧.</p><ol><li>试图通过在.vmx 添加 <code>smbios.reflecthost=&quot;true&quot;</code>这个配置, 希望虚拟机中的 bios 信息跟主机的 bios 信息变成一致的, 后面实验发现好像这并没有用, 至少并不会改变掉那些 VMware 字符串.</li><li>试图通过修改vmware的固件来修改我们的 bios 信息,具体的做法要先通过VMware 自带的工具<code>vmware-vmx</code> 导出vmware 中会用到的固件, 将固件导出成后缀为rom 的文件,然后通过2进制编辑软件把里面的字符串修改掉,在通过在配置文件中加入<code>bios440.filename = &quot;bios440.rom&quot;</code>这样的配置参数,来调用我们修改过的固件作为系统的 bios, 这里的 bios440.rom 要放在和虚拟机配置文件一样的目录.</li></ol><p>上述的方法,第二种方法浪费了我大量的时间查找资料结果还是然并卵.这些方法都无法阻止 VMProtect 对于虚拟机的检测, 所以目前能采用的方法只能通过挂钩函数这一种了, 如果以后能有机会找到更好的方法, 我会更新在这篇文章里面.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://pete.akeo.ie/2011/06/extracting-and-using-modified-vmware.html" target="_blank" rel="external">http://pete.akeo.ie/2011/06/extracting-and-using-modified-vmware.html</a></p><p><a href="http://blog.xuite.net/kai0227/notebook/82868890-%E4%BF%AE%E6%94%B9VMware+BIOS" target="_blank" rel="external">http://blog.xuite.net/kai0227/notebook/82868890-%E4%BF%AE%E6%94%B9VMware+BIOS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章主要记录一下在处理 VMProtect 在WIN7系统中的虚拟机检测中, 走的一些弯路.避免老路重走的悲情…&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="hack" scheme="http://MBTimY.github.io/tags/hack/"/>
    
      <category term="binary" scheme="http://MBTimY.github.io/tags/binary/"/>
    
      <category term="package" scheme="http://MBTimY.github.io/tags/package/"/>
    
  </entry>
  
  <entry>
    <title>vmprotect_vmdetect</title>
    <link href="http://MBTimY.github.io/2017/09/30/vmprotect-vmdetect/"/>
    <id>http://MBTimY.github.io/2017/09/30/vmprotect-vmdetect/</id>
    <published>2017-09-29T17:38:33.000Z</published>
    <updated>2017-09-29T19:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VMProtect-3-X-虚拟机检测部分的记录"><a href="#VMProtect-3-X-虚拟机检测部分的记录" class="headerlink" title="VMProtect 3.X 虚拟机检测部分的记录"></a>VMProtect 3.X 虚拟机检测部分的记录</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>VMProtect 壳(下面简称为: VMP)进入了3.X 时代, 添加了很多新的 anti-debug vmdetect 等的反逆向人员分析的手段, 这篇文章主要记录VMP 中对于虚拟机检测这块的相关技术.</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>虚拟机检测是很多程序为了判断自身是否处于非真实机所用的技术手段,对于 VMP 这样的高强度加密壳, 这项功能可能仅仅只是它锦上添花的一种行为,所以它自身的虚拟机检测手段并没有无所不用其极,检测的方式相对单一,下面我会依照参考的一些资料详细的说明一下 VMP 对于 VMware 这款虚拟机的检测.</p><h3 id="检测技术手段"><a href="#检测技术手段" class="headerlink" title="检测技术手段"></a>检测技术手段</h3><ul><li>VMP3.X 使用了 <code>CPUID</code> 这么一个特权指令来作为检测程序本身是否处于 VMware 中的一个强有力手段, 具体的做法是: 在执行<code>CPUID</code> 这个指令的时候将 EAX 寄存器设置为1这个 int 值, 当执行完前面的指令后, 此命令会将指令结果分别放在 EAX,EBX,ECX,EDX.我们这里只关心 ECX 寄存器中的结果, 此结果保存了一些特性的标志位使用的是寄存器中的位来作为标记的,我们这里只关心第31位(也就是寄存器的最高位)是否为1,这个位置在真是机中是不会被设置为1的,只有在虚拟机中才有可能被设置为1,具体的原理部分可以参考<a href="https://en.wikipedia.org/wiki/CPUID#EAX.3D1:_Processor_Info_and_Feature_Bits" target="_blank" rel="external">Processor_Info_and_Feature_Bits</a>这个 wiki.</li><li>VMP3.X 使用的另一项检测技术是, 检测虚拟机的硬件信息中是否包含有” VMware “这样的字符串来判断的, 在 XP 中采用的是通过 <code>ZwOpenSection</code>和<code>ZwMapViewOfSection</code>这两个函数来获取内存硬件中比较低的地址中存放的一些关于系统中的 bios 的相关信息来判断是否处于虚拟机中. 不过在 WIN7 系统中由于上面的方式不再允许直接打开内存硬件对象,所以换做了<code>LocalAlloc EnumSystemFirmwareTables GetSystemFirmwareTable</code>来实现相同的目的.</li></ul><h3 id="Patch手段"><a href="#Patch手段" class="headerlink" title="Patch手段"></a>Patch手段</h3><p>上面介绍的检测手段中第一种方式,通过修改 Vmware的配置文件可以简单的 Patch 掉. 配置参数如下:</p><blockquote><p>hypervisor.cpuid.v0 = “FALSE”</p><p>hypervisor.cpuid.v1 = “FALSE”</p></blockquote><p>另一项检测手段,暂时没有找到修改配置文件可以解决的方法,目前能想到的只有自己编写一个脚本或者插件来 HOOK 获取系统相关信息的函数来防止这些信息的获取,阻止VMP程序判定.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=635613" target="_blank" rel="external">VMP v3.0.9过VMware检测</a></p><p><a href="http://www.hexacorn.com/blog/2014/08/25/protecting-vmware-from-cpuid-hypervisor-detection/" target="_blank" rel="external">Protecting VMWare from CPUID hypervisor detection</a></p><p><a href="https://forum.tuts4you.com/topic/38701-vmprotect-ultimate-308/?page=0#comment-185039" target="_blank" rel="external">VMProtect Ultimate 3.0.8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VMProtect-3-X-虚拟机检测部分的记录&quot;&gt;&lt;a href=&quot;#VMProtect-3-X-虚拟机检测部分的记录&quot; class=&quot;headerlink&quot; title=&quot;VMProtect 3.X 虚拟机检测部分的记录&quot;&gt;&lt;/a&gt;VMProtect 3.X 
      
    
    </summary>
    
    
      <category term="hack" scheme="http://MBTimY.github.io/tags/hack/"/>
    
      <category term="binary" scheme="http://MBTimY.github.io/tags/binary/"/>
    
      <category term="package" scheme="http://MBTimY.github.io/tags/package/"/>
    
  </entry>
  
  <entry>
    <title>反调试经验汇总</title>
    <link href="http://MBTimY.github.io/2017/09/26/%E5%8F%8D%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"/>
    <id>http://MBTimY.github.io/2017/09/26/反调试经验汇总/</id>
    <published>2017-09-26T14:03:35.000Z</published>
    <updated>2017-10-18T20:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AntiDebug-经验汇总"><a href="#AntiDebug-经验汇总" class="headerlink" title="AntiDebug 经验汇总"></a>AntiDebug 经验汇总</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在反汇编, 反调试的工作中经常会遇到很多程序为了保证自身代码不被窥探而做出各式各样的手动来阻止逆向人员.<br>常见的主要从两个方向来阻止自身代码被窥探:反调试和反汇编.<br>这篇文章我主要总结一些反调试的手段,文章中大量的内容主要参考网络中的一些前辈们的思想,此文章主要做一个收集总结的作用,方便查阅.</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>反调试的方法千奇百怪,不过目的却只有一个,让自己编写的程序不被调试这种东西开启,加载上进行正常的调试行为.围绕这个目的,市面上的反调试手段可以分成下面的几种方式:</p><ol><li>针对具体的调试软件(如: ollydbg, x64dbg …)的行为,和特征进行扫描检测</li><li>针对调试器的调试功能进行反向的狙击(如:清空硬件断点,反代码追踪 …)</li><li>针对程序在运行时处于被 debug 状态下和正常执行状态下的差异(如:计算执行同一条指令的时间差值, 不同的 CPU 指令在两个状态下的差异 …)</li><li>利用驱动在 ring0 层保护程序不被调试(如:清空 debugport, 阻止对程序内存的读写 …)</li></ol><p>上述的三种方式, 是我在调试逆向中经常遇见的.其中每一种反调试的方式都有很多不同的具体实现.要想把所有的具体实现收集完显得很不现实,但是我会尽量收集一些我从工作或者其他文章中看见的奇淫怪招放进来.有些直接从网络上,或者其他资料上面收集到的信息我会直接引用到我的文章中.一些我自己在实战中碰到的,可能会较为仔细的编写.</p><h3 id="一些简单的反调试和反追踪技术"><a href="#一些简单的反调试和反追踪技术" class="headerlink" title="一些简单的反调试和反追踪技术"></a>一些简单的反调试和反追踪技术</h3><blockquote><p>(1) kernel32!IsDebuggerPresent<br>IsDebuggerPresent returns 1 if the process is being debugged, 0 otherwise. This API simply reads the PEB!BeingDebugged byte-flag (located at offset 2 in the PEB structure).<br>Circumventing it is as easy as setting PEB!BeingDebugged to 0.<br>Example:<br>call IsDebuggerPresent<br>test eax, eax<br>jne @DebuggerDetected<br>…</p><p>(2) PEB!IsDebugged</p><p>This field refers to the second byte in the Process Environment Block of the process. It is set by the system when the process is debugged.<br>This byte can be reset to 0 without consequences for the course of execution of the program (it is an informative flag).</p><p>Example:<br>mov eax, fs:[30h]<br>mov eax, byte [eax+2]<br>test eax, eax<br>jne @DebuggerDetected<br>…</p><p>(3) PEB!NtGlobalFlags</p><p>When a process is created, the system sets some flags that will define how various APIs will behave for this program. Those flags can be read in the PEB, in the DWORD located at offset 0x68 (see the reference).<br>By default, different flags are set depending if the process is created under a debugger or not. If the process is debugged, some flags controlling the heap manipulation routines in ntdll will be set: FLG_HEAP_ENABLE_TAIL_CHECK &amp; FLG_HEAP_ENABLE_FREE_CHECK &amp; FLG_HEAP_VALIDATE_PARAMETERS.<br>This anti-debug can be bypassed by resetting the NtGlobalFlags field.</p><p>Example:<br>mov eax, fs:[30h]<br>mov eax, [eax+68h]<br>and eax, 0x70<br>test eax, eax<br>jne @DebuggerDetected<br>…</p><p>(4) Heap flags</p><p>As explained previously, NtGlobalFlags informs how the heap routines will behave (among other things). Though it is easy to modify the PEB field, if the heap does not behave the same way as it should when the process is not debugged, this could be problematic. It is a powerful anti-debug, as process heaps are numerous, and their chunks can be individually affected by the FLG<em>HEAP</em>* flags (such as chunk tails). Heap headers would be affected as well. For instance, checking the field ForceFlags in a heap header (offset 0x10) can be used to detect the presence of a debugger.</p><p>There are two easy ways to circumvent it:</p><ul><li><p>Create a non-debugged process, and attach the debugger once the process has been created (an easy solution is to create the process suspended, run until the entry-point is reached, patch it to an infinite loop, resume the process, attach the debugger, and restore the original entry-point).</p></li><li><p>Force the NtGlobalFlags for the process that we want to debug, via the registry key “HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options”: Create a subkey (not value) named as your process name, and under this subkey, a String value “GlobalFlags” set to nothing.</p></li></ul><p>Example:<br>mov eax, fs:[30h]<br>mov eax, [eax+18h] ;process heap<br>mov eax, [eax+10h] ;heap flags<br>test eax, eax<br>jne @DebuggerDetected<br>…</p><p>(5) Vista anti-debug (no name)</p><p>Here’s an anti-debug specific to Windows Vista that I found by comparing memory dumps of a program running with and without control of a debugger. I’m not sure of its realiability, but it’s worth mentionning (tested on Windows Vista 32 bits, SP0, English version).</p><p>When a process is debugged, its main thread TEB, at offset 0xBFC, contains a pointer to a unicode string referencing a system dll. Moreover, the string follows this pointer (therefore, located at offset 0xC00 in the TEB). If the process is not debugged, the pointer is set to NULL and the string is not present.</p><p>Example:<br>call GetVersion<br>cmp al, 6<br>jne @NotVista<br>push offset _seh<br>push dword fs:[0]<br>mov fs:[0], esp<br>mov eax, fs:[18h] ; teb<br>add eax, 0BFCh<br>mov ebx, [eax] ; pointer to a unicode string<br>test ebx, ebx ; (ntdll.dll, gdi32.dll,…)<br>je @DebuggerNotFound<br>sub ebx, eax ; the unicode string follows the<br>sub ebx, 4 ; pointer<br>jne @DebuggerNotFound<br>;debugger detected if it reaches this point<br>;…</p><footer><strong>@Nicolas Falliere</strong><cite><a href="https://www.symantec.com/connect/articles/windows-anti-debug-reference" target="_blank" rel="external">www.symantec.com/connect/articles/windows-anti-debug-reference</a></cite></footer></blockquote><h3 id="利用程序在-debug-和非-debuged-状态下的差异的反调试手段"><a href="#利用程序在-debug-和非-debuged-状态下的差异的反调试手段" class="headerlink" title="利用程序在 debug 和非 debuged 状态下的差异的反调试手段"></a>利用程序在 debug 和非 debuged 状态下的差异的反调试手段</h3><blockquote><p>(1) NtQueryInformationProcess<br>ntdll!NtQueryInformationProcess is a wrapper around the ZwQueryInformationProcess syscall. Its prototype is the following:</p><p>NTSYSAPI NTSTATUS NTAPI NtQueryInformationProcess(<br>IN HANDLE ProcessHandle,<br>IN PROCESS_INFORMATION_CLASS ProcessInformationClass,<br>OUT PVOID ProcessInformation,<br>IN ULONG ProcessInformationLength,<br>OUT PULONG ReturnLength<br>);</p><p>When called with ProcessInformationClass set to 7 (ProcessDebugPort constant), the system will set ProcessInformation to -1 if the process is debugged.<br>It is a powerful anti-debug, and there is no easy way to circumvent it. However, if the program is traced, ProcessInformation can be modified when the syscall returns.</p><p>Another solution is to use a system driver that would hook the ZwNtQueryInformationProcess syscall.<br>Circumventing NtQueryInformationProcess will bypass many anti-debug techniques (such as CheckRemoteDebuggerPresent or UnhandledExceptionFilter).</p><p>Example:<br>push 0<br>push 4<br>push offset isdebugged<br>push 7 ;ProcessDebugPort<br>push -1<br>call NtQueryInformationProcess<br>test eax, eax<br>jne @ExitError<br>cmp isdebugged, 0<br>jne @DebuggerDetected<br>…</p><p>(2) kernel32!CheckRemoteDebuggerPresent</p><p>This API takes two parameters: a process handle, and a pointer to a DWORD. If the call is successful, the DWORD value will be set to 1 if the process is being debugged.<br>Internally, this API calls ntdll!NtQueryInformationProcess with ProcessInformationClass set to ProcessDebugPort (7).</p><p>Example:<br>push offset isdebugged<br>push -1<br>call CheckRemoteDebuggerPresent<br>test eax, eax<br>jne @DebuggerDetected<br>…</p><p>(3) UnhandledExceptionFilter</p><p>When an exception occurs, with Windows XP SP&gt;=2, Windows 2003, and Windows Vista, the usual way the OS processes the exception is:</p><ul><li>If any, pass control to the per-process Vectored Exception Handlers.</li><li>If the exception is not processed, pass the control to the per-thread top SEH handler, pointed by FS:[0] in the thread that generated the exception. SEH are chained and called in turn if the exception is not processed by the previous in the chain.</li><li>If the exception has not been processed by any of the previous handlers, the final SEH handler (set by the system), will call kernel32!UnhandledExceptionFilter. This function will decide what it should do depending if the process is debugged or not.</li><li>If it is not debugged, it will call the user-defined filter function (set via kernel32!SetUnhandledExceptionFilter).</li><li>If it debugged, the program will be terminated.</li></ul><p>The debugger detection in UnhandledExceptionFilter is made with ntdll!NtQueryInformationProcess.</p><p>Example:<br>push @not_debugged<br>call SetUnhandledExceptionFilter<br>xor eax, eax<br>mov eax, dword [eax] ; trigger exception<br>;program terminated if debugged<br>;…<br>@not_debugged:<br>;process the exception<br>;continue the execution<br>;…</p><p>(4) NtSetInformationThread<br>ntdll!NtSetInformationThread is a wrapper around the ZwSetInformationThread syscall. Its prototype is the following:<br>NTSYSAPI NTSTATUS NTAPI NtSetInformationThread(<br>IN HANDLE ThreadHandle,<br>IN THREAD_INFORMATION_CLASS ThreadInformationClass,<br>IN PVOID ThreadInformation,<br>IN ULONG ThreadInformationLength<br>);</p><p>When called with ThreadInformationClass set to 0x11 (ThreadHideFromDebugger constant), the thread will be detached from the debugger.</p><p>Similarly to ZwQueryInformationProcess, circumventing this anti-debug requires either modifying ZwSetInformationThread parameters before it’s called, or hooking the syscall directly with the use of a kernel driver.</p><p>Example:<br>push 0<br>push 0<br>push 11h ;ThreadHideFromDebugger<br>push -2<br>call NtSetInformationThread<br>;thread detached if debugged<br>;…</p><p>(5) kernel32!CloseHandle and NtClose</p><p>APIs making user of the ZwClose syscall (such as CloseHandle, indirectly) can be used to detect a debugger. When a process is debugged, calling ZwClose with an invalid handle will generate a STATUS_INVALID_HANDLE (0xC0000008) exception.</p><p>As with all anti-debugs that rely on information made directly available from the kernel (therefore involving a syscall), the only proper way to bypass the “CloseHandle” anti-debug is to either modify the syscall data from ring3, before it is called, or set up a kernel hook.</p><p>This anti-debug, though extremely powerful, does not seem to be widely used by malicious programs.</p><p>Example:<br>push offset @not_debugged<br>push dword fs:[0]<br>mov fs:[0], esp<br>push 1234h ;invalid handle<br>call CloseHandle<br>; if fall here, process is debugged<br>;…<br>@not_debugged:<br>;…</p><p>(6) Self-debugging</p><p>A process can detect it is being debugged by trying to debug itself, for instance by creating a new process, and calling kernel32!DebugActiveProcess(pid) on the parent process.</p><p>In turn, this API calls ntdll!DbgUiDebugActiveProcess which will call the syscall ZwDebugActiveProcess. If the process is already debugged, the syscall fails. Note that retrieving the parent process PID can be done with the toolhelp32 APIs (field th32ParentProcessID in the PROCESSENTRY32 structure.</p><p>(7) Kernel-mode timers</p><p>kernel32!QueryPerformanceCounter is an efficent anti-debug. This API calls ntdll!NtQueryPerformanceCounter which wraps the ZwQueryPerformanceCounter syscall.</p><p>Again, there is no easy way to circumvent this anti-tracing trick.</p><p>(8) User-mode timers</p><p>An API such as kernel32!GetTickCount returns the number of milliseconds ellapsed since the system started. The interesting thing is that it does not make use of kernel-related service to perform its duties. A user-mode process has this counter mapped in its address space. For 8Gb user-mode spaces, the value returned would be:</p><p>d[0x7FFE0000] * d[0x7FFE0004] / (2^24)</p><p>(9) kernel32!OutputDebugStringA</p><p>This anti-debug is quite original, I have encountered it only once, in files packed with ReCrypt v0.80. The trick consists of calling OutputDebugStringA, with a valid ASCII string. If the program is run under control of a debugger, the return value will be the address of the string passed as a parameter. In normal conditions, the return value should be 1.</p><p>Example:<br>xor eax, eax<br>push offset szHello<br>call OutputDebugStringA<br>cmp eax, 1<br>jne @DebuggerDetected<br>…</p><p>(10) Ctrl-C</p><p>When a console program is debugged, a Ctrl-C signal will throw a EXCEPTION_CTL_C exception, whereas the signal handler would be called directly is the program is not debugged.</p><p>Example:<br>push offset exhandler<br>push 1<br>call RtlAddVectoredExceptionHandler<br>push 1<br>push sighandler<br>call SetConsoleCtrlHandler<br>push 0<br>push CTRL_C_EVENT<br>call GenerateConsoleCtrlEvent<br>push 10000<br>call Sleep<br>push 0<br>call ExitProcess<br>exhandler:<br>;check if EXCEPTION_CTL_C, if it is,<br>;debugger detected, should exit process<br>;…<br>sighandler:<br>;continue<br>;…</p><footer><strong>@Nicolas Falliere</strong><cite><a href="https://www.symantec.com/connect/articles/windows-anti-debug-reference" target="_blank" rel="external">www.symantec.com/connect/articles/windows-anti-debug-reference</a></cite></footer></blockquote><h3 id="基于-CPU-特性的反调试手段"><a href="#基于-CPU-特性的反调试手段" class="headerlink" title="基于 CPU 特性的反调试手段"></a>基于 CPU 特性的反调试手段</h3><blockquote><p>(1) Rogue Int3</p><p>This is a classic anti-debug to fool weak debuggers. It consists of inserting an INT3 opcode in the middle of a valid sequence of instructions. When the INT3 is executed, if the program is not debugged, control will be given to the exception handler of the protection and execution will continue.</p><p>As INT3 instructions are used by debuggers to set software breakpoints, inserting INT3 opcodes can be used to trick the debugger into believing that it is one his breakpoints. Therefore, the control would not be given to the exception handler, and the course of the program would be modified. Debuggers should track where they set software breakpoints to avoid falling for this one.</p><p>Similarly, note that INT3 may be encoded as 0xCD, 0x03.</p><p>Example:<br>push offset @handler<br>push dword fs:[0]<br>mov fs:[0], esp<br>;…<br>db 0CCh<br>;if fall here, debugged<br>;…<br>@handler:<br>;continue execution<br>;…</p><p>(2) “Ice” Breakpoint</p><p>The so-called “Ice breakpoint” is one of Intel’s undocumented instruction, opcode 0xF1. It is used to detect tracing programs.</p><p>Executing this instruction will generate a SINGLE_STEP exception. Therefore, if the program is already traced, the debugger will think it is the normal exception generated by executing the instruction with the SingleStep bit set in the Flags registers. The associated exception handler won’t be executed, and execution will not continue as expected.<br>Bypassing this trick is easy: one can run over the instruction, instead and single-stepping on it. The exception will be generated, but since the program is not traced, the debugger should understand that it has to pass control to the exception handler.</p><p>Example:<br>push offset @handler<br>push dword fs:[0]<br>mov fs:[0], esp<br>;…<br>db 0F1h<br>;if fall here, traced<br>;…<br>@handler:<br>;continue execution<br>;…</p><p>(3) Interrupt 2Dh</p><p>Executing this interrupt if the program is not debugged will raise a breakpoint exception. If the program is debugged, and the instruction is not executed with the trace flag, no exception will be generated, and execution will carry on normally. If the program is debugged and the instruction traced, the following byte will be skipped, and execution will continue. Therefore, using INT 2Dh can be used as a powerful anti-debug and anti-tracer mechanism.<br>Example:<br>push offset @handler<br>push dword fs:[0]<br>mov fs:[0], esp<br>;…<br>db 02Dh<br>mov eax, 1 ;anti-tracing<br>;…<br>@handler:<br>;continue execution<br>;…</p><p>(4) Timestamp counters<br>High precision counters, storing the current number of CPU cycles executed since the machine started, can be queried with the RDTSC instruction. Classic anti-debugs consist of measuring time deltas at key points in the program, usually around exception handlers. If the delta is too large, that would mean the program runs under control of a debugger (processing the exception in the debugger, and giving control back to the debuggee is a lengthy task).</p><p>Example:<br>push offset handler<br>push dword ptr fs:[0]<br>mov fs:[0],esp<br>rdtsc<br>push eax<br>xor eax, eax<br>div eax ;trigger exception<br>rdtsc<br>sub eax, [esp] ;ticks delta<br>add esp, 4<br>pop fs:[0]<br>add esp, 4<br>cmp eax, 10000h ;threshold<br>jb @not_debugged<br>@debugged:<br>…<br>@not_debugged:<br>…<br>handler:<br>mov ecx, [esp+0Ch]<br>add dword ptr [ecx+0B8h], 2 ;skip div<br>xor eax, eax<br>ret</p><p>(5) Popf and the trap flag</p><p>The trap flag, located in the Flags register, controls the tracing of a program. If this flag is set, executing an instruction will also raise a SINGLE_STEP exception. The trap flag can be manipulated in order to thwart tracers. For instance, this sequence of instructions will set the trap flag:</p><p>pushf<br>mov dword [esp], 0x100<br>popf</p><p>If the program is being traced, this will have no real effect on the flags register, and the debugger will process the exception, believing it comes from regular tracing. The exception handler won’t be executed. Circumventing this anti-tracer trick simply require to run over the pushf instruction.</p><p>(6) Stack Segment register</p><p>Here’s a very original anti-tracer. I encountered it in a packer called MarCrypt. I believe it is not widely known, not to mention, used.<br>It consists of tracing over this sequence of instructions:</p><p>push ss<br>pop ss<br>pushf<br>nop</p><p>When tracing over pop ss, the next instruction will be executed but the debugger will not break on it, therefore stopping on the following instruction (NOP in this case).<br>Marcrypt uses this anti-debug the following way:</p><p>push ss<br>; junk<br>pop ss<br>pushf<br>; junk<br>pop eax<br>and eax, 0x100<br>or eax, eax<br>jnz @debugged<br>; carry on normal execution</p><p>The trick here is that, if the debugger is tracing over that sequence of instructions, popf will be excuted implicitly, and the debugger will not be able to unset the trapflag in the pushed value on the stack. The protection checks for the trap flag and terminates the program if it’s found.<br>One simple way to circumvent this anti-tracing is to breakpoint on popf and run the program (to avoid using the TF flag).</p><p>(7) Debug registers manipulation</p><p>Debug registers (DR0 through DR7) are used to set hardware breakpoints. A protection can manipulate them to either detect that hardware breakpoints have been set (and therefore, that it is being debugged), reset them or set them to particular values used to perform code checks later. A packer such as tElock makes use of the debug registers to prevent reverse-engineers from using them.<br>From a user-mode perspective, debug registers cannot be set using the privileged ‘mov drx, …’ instruction. Other ways exist:</p><ul><li><p>An exception can be generated, the thread context modified (it contains the CPU registers at the time the exception was thrown), and then resumed to normal execution with the new context.</p></li><li><p>The other way is to use the NtGetContextThread and NtSetContextThread syscalls (available in kernel32 with GetThreadContext and SetThreadContext).</p></li></ul><p>Most protectors use the first, “unofficial” way.</p><p>Example:<br>push offset handler<br>push dword ptr fs:[0]<br>mov fs:[0],esp<br>xor eax, eax<br>div eax ;generate exception<br>pop fs:[0]<br>add esp, 4<br>;continue execution<br>;…<br>handler:<br>mov ecx, [esp+0Ch] ;skip div<br>add dword ptr [ecx+0B8h], 2 ;skip div<br>mov dword ptr [ecx+04h], 0 ;clean dr0<br>mov dword ptr [ecx+08h], 0 ;clean dr1<br>mov dword ptr [ecx+0Ch], 0 ;clean dr2<br>mov dword ptr [ecx+10h], 0 ;clean dr3<br>mov dword ptr [ecx+14h], 0 ;clean dr6<br>mov dword ptr [ecx+18h], 0 ;clean dr7<br>xor eax, eax<br>ret</p><p>(8) Context modification</p><p>As with debug registers manipulation, the context can also be used to modify in an unconventionnal way the execution stream of a program. Debuggers can get easily confused!<br>Note that another syscall, NtContinue, can be used to load a new context in the current thread (for instance, this syscall is used by the exception handler manager).</p><footer><strong>@Nicolas Falliere</strong><cite><a href="https://www.symantec.com/connect/articles/windows-anti-debug-reference" target="_blank" rel="external">www.symantec.com/connect/articles/windows-anti-debug-reference</a></cite></footer></blockquote><h3 id="一些不好分类的调试手段"><a href="#一些不好分类的调试手段" class="headerlink" title="一些不好分类的调试手段"></a>一些不好分类的调试手段</h3><blockquote><p>(1) TLS-callback</p><p>This anti-debug was not so well-known a few years ago. It consists to instruct the PE loader that the first entry point of the program is referenced in a Thread Local Storage entry (10th directory entry number in the PE optional header). By doing so, the program entry-point won’t be executed first. The TLS entry can then perform anti-debug checks in a stealthy way.<br>Note that in practice, this technique is not widely used.<br>Though older debuggers (including OllyDbg) are not TLS-aware, counter-measures are quite easy to take, by the means of plugins of custom patcher tools.</p><p>(2) CC scanning</p><p>A common protection feature used by packers is the CC-scanning loop, aimed at detecting software breakpoints set by a debugger. If you want to avoid that kind of troubles, you may want to use either hardware breakpoints or a custom type of software breakpoint. CLI (0xFA) is a good candidate to replace the classic INT3 opcode. This instruction does have the requirements for the job: it raises a privileged instruction exception if executed by a ring3 program, and occupies only 1 byte of space.</p><p>(3) EntryPoint RVA set to 0</p><p>Some packed files have their entry point RVA set to 0, which means they will start executing ‘MZ…’ which corresponds to ‘dec ebx / pop edx …’.</p><p>This is not an anti-debug trick in itself, but can be annoying if you want to break on the entry-point by using a software breakpoint.</p><p>If you create a suspended process, then set an INT3 at RVA 0, you will erase part of the magic MZ value (‘M’). The magic was checked when the process was created, but it will get checked again by ntdll when the process is resumed (in the hope of reaching the entry-point). In that case, an INVALID_IMAGE_FORMAT exception will be raised.</p><p>If you create your own tracing or debugging tool, you will want to use hardware breakpoint to avoid this problem.</p><footer><strong>@Nicolas Falliere</strong><cite><a href="https://www.symantec.com/connect/articles/windows-anti-debug-reference" target="_blank" rel="external">www.symantec.com/connect/articles/windows-anti-debug-reference</a></cite></footer></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.symantec.com/connect/articles/windows-anti-debug-reference" target="_blank" rel="external">windows Anti-debug reference</a></li><li><a href="http://www.openrce.org/reference_library/anti_reversing" target="_blank" rel="external">OpenRCE Anti Reverse Engineering Techniques Database</a></li><li><a href="http://blog.csdn.net/feiniao251314/article/details/52384633" target="_blank" rel="external">windows heap manage</a> 方便理解 heap 标志检测那里的内容</li><li><a href="http://blog.sycsec.com/?p=350" target="_blank" rel="external">windows常见反调试手段</a></li><li><a href="https://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide" target="_blank" rel="external">An Anti-Reverse Engineering Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AntiDebug-经验汇总&quot;&gt;&lt;a href=&quot;#AntiDebug-经验汇总&quot; class=&quot;headerlink&quot; title=&quot;AntiDebug 经验汇总&quot;&gt;&lt;/a&gt;AntiDebug 经验汇总&lt;/h1&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="hack" scheme="http://MBTimY.github.io/tags/hack/"/>
    
      <category term="binary" scheme="http://MBTimY.github.io/tags/binary/"/>
    
  </entry>
  
  <entry>
    <title>VMDetect</title>
    <link href="http://MBTimY.github.io/2017/09/24/VMDetect/"/>
    <id>http://MBTimY.github.io/2017/09/24/VMDetect/</id>
    <published>2017-09-23T20:50:34.000Z</published>
    <updated>2017-09-27T20:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录一下各种虚拟机检测的手段"><a href="#记录一下各种虚拟机检测的手段" class="headerlink" title="记录一下各种虚拟机检测的手段"></a>记录一下各种虚拟机检测的手段</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>根据所看的 <em>IDAPRO权威指南</em> 这本书中的一些关于 VM 反检测的连接,这里整合一下现有的一些 VM 反检测手段, 方便自己方便大家.</p><h3 id="第一招-redpill-红丸"><a href="#第一招-redpill-红丸" class="headerlink" title="第一招 redpill(红丸)"></a>第一招 redpill(红丸)</h3><p><em>talk is cheap, show me code</em> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">swallow_redpill</span> <span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> m[<span class="number">2</span>+<span class="number">4</span>], rpill[] = <span class="string">"\x0f\x01\x0d\x00\x00\x00\x00\xc3"</span>;</div><div class="line">   *((<span class="keyword">unsigned</span>*)&amp;rpill[<span class="number">3</span>]) = (<span class="keyword">unsigned</span>)m;</div><div class="line">   ((<span class="keyword">void</span>(*)())&amp;rpill)();</div><div class="line">   <span class="keyword">return</span> (m[<span class="number">5</span>]&gt;<span class="number">0xd0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>上面的代码是红丸这个技术的核心的代码, 从最后的返回值上来看主要是检测一下 m 这个变量的值是否大于0xd0, 但从结果上来说如果是大于这个值的情况该函数会判断自身处于VM 的运行环境下.<br>说完现象, 这里我们探究一下原理, 这里为了节省时间就把看雪中<a href="https://bbs.pediy.com/thread-119969.htm" target="_blank" rel="external">虚拟机检测技术剖析</a>文章中的结果直接放在下面:</p><blockquote><p>利用IDT基址检测虚拟机的方法是一种通用方式，对VMware和Virtual PC均适用。中断描述符表IDT（Interrupt Descriptor Table）用于查找处理中断时所用的软件函数，它是一个由256项组成的数据，其中每一中断对应一项函数。为了读取IDT基址，我们需要通过SIDT指令来读取IDTR（中断描述符表寄存器，用于IDT在内存中的基址），SIDT指令是以如下格式来存储IDTR的内容：由于只存在一个IDTR，但又存在两个操作系统，即虚拟机系统和真主机系统。为了防止发生冲突，VMM（虚拟机监控器）必须更改虚拟机中的IDT地址，利用真主机与虚拟机环境中执行sidt指令的差异即可用于检测虚拟机是否存在。著名的“红丸”（redpill）正是利用此原理来检测VMware的。Redpill作者在VMware上发现虚拟机系统上的IDT地址通常位于0xFFXXXXXX，而Virtual PC通常位于0xE8XXXXXX，而在真实主机上正如图2所示都位于0x80xxxxxx。Redpill仅仅是通过判断执行SIDT指令后返回的第一字节是否大于0xD0，若是则说明它处于虚拟机，否则处于真实主机中。</p></blockquote><h3 id="第二招-特权指令-in-r32-r16-针对-VMware"><a href="#第二招-特权指令-in-r32-r16-针对-VMware" class="headerlink" title="第二招 特权指令 in r32, r16 (针对 VMware)"></a>第二招 特权指令 in r32, r16 (针对 VMware)</h3><p><em>talk is cheap, show me code</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsInsideVMWare</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">bool</span> rc = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">  __try</div><div class="line">  &#123;</div><div class="line">    __asm</div><div class="line">    &#123;</div><div class="line">      push   edx</div><div class="line">      push   ecx</div><div class="line">      push   ebx</div><div class="line"> </div><div class="line">      mov    eax, 'VMXh'</div><div class="line">      mov    ebx, <span class="number">0</span>  <span class="comment">// 将ebx设置为非幻数’VMXH’的其它值</span></div><div class="line">      mov    ecx, <span class="number">10</span> <span class="comment">// 指定功能号，用于获取VMWare版本，当它为0x14时用于获取VMware内存大小</span></div><div class="line">      mov    edx, 'VX' // 端口号</div><div class="line">      in     eax, dx <span class="comment">// 从端口dx读取VMware版本到eax</span></div><div class="line"><span class="comment">//若上面指定功能号为0x14时，可通过判断eax中的值是否大于0，若是则说明处于虚拟机中</span></div><div class="line">      cmp    ebx, 'VMXh' // 判断ebx中是否包含VMware版本’VMXh’，若是则在虚拟机中</div><div class="line">      setz   [rc] <span class="comment">// 设置返回值</span></div><div class="line"> </div><div class="line">      pop    ebx</div><div class="line">      pop    ecx</div><div class="line">      pop    edx</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  __except(EXCEPTION_EXECUTE_HANDLER)  <span class="comment">//如果未处于VMware中，则触发此异常</span></div><div class="line">  &#123;</div><div class="line">    rc = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码摘至第一招中描述的那篇文章中, 这里继续引用文章中原理的部分简单的说明一下为什么这段代码 可以起到检测虚拟机的神奇作用.</p><blockquote><p>Vmware为真主机与虚拟机之间提供了相互沟通的通讯机制，它使用“IN”指令来读取特定端口的数据以进行两机通讯，但由于IN指令属于特权指令，在处于保护模式下的真机上执行此指令时，除非权限允许，否则将会触发类型为“EXCEPTION_PRIV_INSTRUCTION”的异常，而在虚拟机中并不会发生异常，在指定功能号0A（获取VMware版本）的情况下，它会在EBX中返回其版本号“VMXH”；而当功能号为0x14时，可用于获取VMware内存大小，当大于0时则说明处于虚拟机中。</p></blockquote><h3 id="第三招-利用-LDT-GDT-的地址信息来判断"><a href="#第三招-利用-LDT-GDT-的地址信息来判断" class="headerlink" title="第三招 利用 LDT/GDT 的地址信息来判断"></a>第三招 利用 LDT/GDT 的地址信息来判断</h3><p><em>talk is cheap, show me codes</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LDTDetect</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> ldt_addr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ldtr[<span class="number">2</span>];</div><div class="line"> </div><div class="line">    _asm sldt ldtr</div><div class="line">    ldt_addr = *((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)&amp;ldtr);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"LDT BaseAddr: 0x%x\n"</span>, ldt_addr);</div><div class="line"> </div><div class="line">    <span class="keyword">if</span>(ldt_addr == <span class="number">0x0000</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Native OS\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Inside VMware\n"</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GDTDetect</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> gdt_addr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> gdtr[<span class="number">4</span>];</div><div class="line"> </div><div class="line">    _asm sgdt gdtr</div><div class="line">    gdt_addr = *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)&amp;gdtr[<span class="number">2</span>]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"GDT BaseAddr:0x%x\n"</span>, gdt_addr);</div><div class="line"> </div><div class="line">    <span class="keyword">if</span>((gdt_addr &gt;&gt; <span class="number">24</span>) == <span class="number">0xff</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Inside VMware\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Native OS\n"</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    LDTDetect();</div><div class="line">    GDTDetect();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里的检测方法利用的是检测 LDT 和 GDT 这两个记录描述符表的寄存器,所存放的地址来判定的.一样, 这里我们继续引用上述中的文章的部分章节来简单的解释一下原理.</p><blockquote><p>在 《Intel® 64 and IA-32  Architecture Software Developer’s Manual Volume 3A: System Programming Guide》第二章的Vol.3 2-5 一页（我的Intel开发手册是2008版的）中对于LDT和GDT的描述如下（以下内容为个人翻译）：<br>在保护模式下，所有的内存访问都要通过全局描述符表（GDT）或者本地描述符表（LDT）才能进行。这些表包含有段描述符的调用入口。各个段描述符都包含有各段的基址，访问权限，类型和使用信息，而且每个段描述符都拥有一个与之相匹配的段选择子，各个段选择子都为软件程序提供一个GDT或LDT索引（与之相关联的段描述符偏移量），一个全局/本地标志（决定段选择子是指向GDT还是LDT），以及访问权限信息。<br>若想访问段中的某一字节，必须同时提供一个段选择子和一个偏移量。段选择子为段提供可访问的段描述符地址（在GDT 或者LDT 中）。通过段描述符，处理器从中获取段在线性地址空间里的基址，而偏移量用于确定字节地址相对基址的位置。假定处理器在当前权限级别（CPL）可访问这个段，那么通过这种机制就可以访问在GDT 或LDT 中的各种有效代码、数据或者堆栈段，这里的CPL是指当前可执行代码段的保护级别。<br>……<br>GDT的线性基址被保存在GDT寄存器（GDTR）中，而LDT的线性基址被保存在LDT寄存器（LDTR）中。 </p><p>由于虚拟机与真实主机中的GDT和LDT并不能相同，这与使用IDT的检测方法一样，因此虚拟机必须为它们提供一个“复制体”。关于GDT和LDT的基址可通过SGDT和SLDT指令获取。虚拟机检测工具Scoopy suite的作者Tobias Klein经测试发现，当LDT基址位于0x0000（只有两字节）时为真实主机，否则为虚拟机，而当GDT基址位于0xFFXXXXXX时说明处于虚拟机中，否则为真实主机。</p></blockquote><h3 id="第四招-利用-TSS-段选择器来判定"><a href="#第四招-利用-TSS-段选择器来判定" class="headerlink" title="第四招 利用 TSS 段选择器来判定"></a>第四招 利用 TSS 段选择器来判定</h3><p><em>talk is cheap, show me code</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mem[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"> </div><div class="line">    __asm str mem;</div><div class="line">    <span class="built_in">printf</span> (<span class="string">" STR base: 0x"</span>);</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%02x"</span>,mem[i]);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ( (mem[<span class="number">0</span>]==<span class="number">0x00</span>) &amp;&amp; (mem[<span class="number">1</span>]==<span class="number">0x40</span>))</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n INSIDE MATRIX!!\n"</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n Native OS!!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>原理跟上述的几个差不多, 这里利用的是 TSS 这个段选择器的地址在虚拟机和真实机的不同来判定的. 详细的原理继续引用文章中的说法:</p><blockquote><p>在保护模式下运行的所有程序在切换任务时，对于当前任务中指向TSS的段选择器将会被存储在任务寄存器中，TSS中包含有当前任务的可执行环境状态，包括通用寄存器状态，段寄存器状态，标志寄存器状态，EIP寄存器状态等等，当此项任务再次被执行时，处理器就会其原先保存的任务状态。每项任务均有其自己的TSS，而我们可以通过STR指令来获取指向当前任务中TSS的段选择器。这里STR（Store task register）指令是用于将任务寄存器 (TR) 中的段选择器存储到目标操作数，目标操作数可以是通用寄存器或内存位置，使用此指令存储的段选择器指向当前正在运行的任务的任务状态段 (TSS)。在虚拟机和真实主机之中，通过STR读取的地址是不同的，当地址等于0x0040xxxx时，说明处于虚拟机中，否则为真实主机。</p></blockquote><h3 id="第五招-利用虚拟机安装的特定软件来判定"><a href="#第五招-利用虚拟机安装的特定软件来判定" class="headerlink" title="第五招 利用虚拟机安装的特定软件来判定"></a>第五招 利用虚拟机安装的特定软件来判定</h3><p><em>talk is cheap, show me codes</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="number">.386</span></div><div class="line">.model flat, stdcall</div><div class="line">option casemap:none</div><div class="line"> </div><div class="line">   include  windows.inc</div><div class="line">   include  user32.inc</div><div class="line">   include  kernel32.inc</div><div class="line">   include  advapi32.inc</div><div class="line"> </div><div class="line">   includelib  user32.lib</div><div class="line">   includelib  kernel32.lib</div><div class="line">   includelib  advapi32.lib</div><div class="line"> </div><div class="line">.data</div><div class="line">szCaption     db <span class="string">"VMware Detector "</span>,<span class="number">0</span></div><div class="line">szInside         db <span class="string">"Inside VMware!"</span>,<span class="number">0</span></div><div class="line">szOutside              db <span class="string">"Native OS!"</span>,<span class="number">0</span></div><div class="line">szSubKey      db <span class="string">"software\VMWare, Inc.\VMware tools"</span>,<span class="number">0</span></div><div class="line">hKey              dd    ?</div><div class="line"> </div><div class="line">.code</div><div class="line">start:</div><div class="line">  invoke RegOpenKeyEx, HKEY_LOCAL_MACHINE, addr szSubKey, <span class="number">0</span>,\</div><div class="line">                 KEY_WRITE or KEY_READ, addr hKey</div><div class="line">  .if eax == ERROR_SUCCESS</div><div class="line">  invoke MessageBox, NULL,addr szInside, addr szCaption, MB_OK</div><div class="line">  .else</div><div class="line">  invoke MessageBox, NULL,addr szOutside, addr szCaption, MB_OK</div><div class="line">  .endif</div><div class="line">  invoke RegCloseKey,hKey</div><div class="line">  invoke ExitProcess,NULL</div><div class="line">end start</div></pre></td></tr></table></figure></p><p>这里简单的通过搜索注册表中是否存在”software\VMWare, Inc.\VMware tools”这个健值来判定是否处于 vmware 的虚拟机之中, 主要是因为 vmwaretool 这个工具是 vmware 特有的用于与 host 主机进行一些交互行为的软件. 这样的软件在安装的时候都会在 windows 的注册表中注册大量的与软件相关的信息, 透过这些信息来检测也是很多软件常用的行为.<br>下面罗列一些可以用来检测是否在虚拟机中的的注册表信息, 仅供参考(来自上述的看雪文章中):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">项名：HKEY_CLASSES_ROOT\Applications\VMwareHostOpen.exe</div><div class="line">项名：HKEY_CLASSES_ROOT\Installer\Products\C2A6F2EFE6910124C940B2B12CF170FE\ProductName</div><div class="line">键值“VMware Tools”</div><div class="line">项名：HKEY_CLASSES_ROOT\Installer\Products\C2A6F2EFE6910124C940B2B12CF170FE\SourceList\PackageName</div><div class="line">键值：VMware Tools.msi</div><div class="line">项名：HKEY_CURRENT_USER\Printers\DeviceOld</div><div class="line">键值：_#VMwareVirtualPrinter,winspool,TPVM:</div><div class="line">项名：HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0\Identifier</div><div class="line">键值：VMware Virtual IDE Hard Drive</div><div class="line">项名：HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 1\Scsi Bus 0\Target Id 0\Logical Unit Id 0\Identifier</div><div class="line">键值：NECVMWar VMware IDE CDR10</div><div class="line">项名：HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Installer\Products\C2A6F2EFE6910124C940B2B12CF170FE\ProductName</div><div class="line">键值：VMware Tools</div><div class="line">项名：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Products\C2A6F2EFE6910124C940B2B12CF170FE\InstallProperties\DisplayName</div><div class="line">键值：VMware Tools</div><div class="line">项名：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Reinstall\0002\DeviceDesc</div><div class="line">键值：VMware SVGA II</div><div class="line">项名：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards\2\Description</div><div class="line">键值：VMware Accelerated AMD PCNet Adapter</div><div class="line">项名：HKEY_LOCAL_MACHINE\SOFTWARE\VMware, Inc.\VMware Tools</div><div class="line">项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&#123;4D36E968-E325-11CE-BFC1-08002BE10318&#125;\0000\DriverDesc</div><div class="line">键值：VMware SVGA II</div><div class="line">项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&#123;4D36E968-E325-11CE-BFC1-08002BE10318&#125;\0000\ProviderName</div><div class="line">键值：VMware, Inc.</div><div class="line">项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&#123;4D36E972-E325-11CE-BFC1-08002bE10318&#125;\0001\DriverDesc</div><div class="line">键值：VMware Accelerated AMD PCNet Adapter</div><div class="line">项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&#123;4D36E97B-E325-11CE-BFC1-08002BE10318&#125;\0000\DriverDesc</div><div class="line">键值：VMware SCSI Controller</div><div class="line">项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Print\Monitors\ThinPrint Print Port Monitor for VMWare</div></pre></td></tr></table></figure></p><h3 id="第六招-利用程序运行的时间差来检测"><a href="#第六招-利用程序运行的时间差来检测" class="headerlink" title="第六招 利用程序运行的时间差来检测"></a>第六招 利用程序运行的时间差来检测</h3><p><em>talk is cheap, show me codes</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="number">.586</span>p</div><div class="line">.model flat, stdcall</div><div class="line">option casemap:none</div><div class="line"> </div><div class="line">include         windows.inc</div><div class="line">include             kernel32.inc</div><div class="line">include         user32.inc</div><div class="line"> </div><div class="line">includelib      kernel32.lib</div><div class="line">includelib      user32.lib</div><div class="line"> </div><div class="line">             </div><div class="line">.data</div><div class="line">szTitle         db  <span class="string">"VMDetect With RDTSC"</span>, <span class="number">0</span>h</div><div class="line">szInsideVM      db  <span class="string">"Inside VMware!"</span>, <span class="number">0</span>h</div><div class="line">szOutsideVM     db  <span class="string">"Native OS!"</span>, <span class="number">0</span>h</div><div class="line"> </div><div class="line">.code</div><div class="line"> </div><div class="line">start:</div><div class="line">    RDTSC</div><div class="line">    xchg        ecx, eax</div><div class="line">    RDTSC  </div><div class="line">    sub     eax, ecx</div><div class="line">    cmp     eax, <span class="number">0</span>FFh</div><div class="line">    jg      Detected</div><div class="line">     </div><div class="line">    invoke  MessageBox, <span class="number">0</span>, offset szOutsideVM, offset szTitle, <span class="number">0</span></div><div class="line">    ret</div><div class="line">     </div><div class="line">Detected:</div><div class="line">    invoke  MessageBox, <span class="number">0</span>, offset szInsideVM, offset szTitle, <span class="number">0</span></div><div class="line">    ret</div><div class="line">end start</div></pre></td></tr></table></figure></p><p>这里用到的方法是通过判定在虚拟机和真实机之间, 对于一个相同的汇编指令 “xchg ecx,eax” 执行起来所用到的时间消耗不一致来进行检测, 不过我认为这种方法的可行性并不是特别高, 因为检测的阈值不是特别好判断, 而且用户的机器上面可能出现各种情况, 如果采用这种方法很容易误报.<br>这里记录这个方法只是为了丰富一些检测方法, 下面引用一下上述看雪文章中作者的理论:</p><blockquote><p>本方法通过运行一段特定代码，然后比较这段代码在虚拟机和真实主机之中的相对运行时间，以此来判断是否处于虚拟机之中。这段代码我们可以通过RDTSC指令来实现，RDTSC指令是用于将计算机启动以来的CPU运行周期数存放到EDX：EAX里面，其中EDX是高位，而EAX是低位。下面我们以xchg    ecx,  eax 一句指令的运行时间为例，这段指令在我的真实主机windows 7系统上的运行时间为0000001E,而该指令在虚拟机WinXP下的运行时间为00000442.</p><p>两者之间的运行时间明显差别很多，在虚拟机中的运行速度远不如真实主机的，一般情况下，当它的运行时间大于0xFF时，就可以确定它处于虚拟机之中了.</p></blockquote><h3 id="第七招-检测虚拟机中特定的硬件信息"><a href="#第七招-检测虚拟机中特定的硬件信息" class="headerlink" title="第七招 检测虚拟机中特定的硬件信息"></a>第七招 检测虚拟机中特定的硬件信息</h3><blockquote><p>Virtual machines make use of virtual hardware abstraction layers to pro- vide the interface between the virtual machine and the host computer’s native hardware. Characteristics of the virtual hardware are often easily detectable by software running within the virtual machine. For example, VMware has been assigned its own organizationally unique identifiers (OUI) 21 for use with its virtualized network adapters. Observing a VMware-specific OUI is a good indication that a program is running within a virtual machine. Note that it is usually possible to modify the MAC address assigned to virtual network adapters using configuration options on the host computer.</p><footer><strong>@the idapro book</strong></footer></blockquote><p>上面的文字描述了虚拟机检测硬件信息的基本上思想, 这种检测虚拟机硬件的特定信息的方法可能有很多种具体的实现, 主要是针对于不同的虚拟机产品.其中也包括了上述第五招用的通过注册表中的信息来检测一些特定硬件包含的字符串,下面分享两个我看见的方法:</p><ul><li><p>VMware默认的网卡MAC地址前缀为“00-05-69，00-0C-29或者00-50-56”，这前3节是由VMware分配的唯一标识符OUI，以供它的虚拟化适配器使用,通过检测前三节就可以判定自身处于虚拟机中.</p></li><li><p>还有一种检测硬盘 modal number 的方法, 可以直接在<a href="https://bbs.pediy.com/thread-110046.htm" target="_blank" rel="external">这里</a>查看</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上的方法都是出自<a href="https://bbs.pediy.com/thread-119969.htm" target="_blank" rel="external">虚拟机检测技术剖析</a>一文中,这里面包含大部分的检测虚拟机的手段.我这里写出来这些主要是为了自己以后方便查询,接下来我贴出一些 IDAPRO 中推荐的参考链接,链接中包含的检测虚拟机手段基本上在原理上面跟上述的文章中大致没有什么太大的区别,主要是针对一些不同的虚拟机产品和特定的一些指令上面有着不同.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><ul><li><a href="https://www.codeproject.com/Articles/9823/Detect-if-your-program-is-running-inside-a-Virtual" target="_blank" rel="external">Detect if your program is running inside a Virtual Machine</a> 这里演示了两种检测虚拟机的方法, 其中一种 redpill 上面的文章已经介绍, 另外一种是用来检测 VirtualPC的, 主要是针对一个特定只能运行在 VirtualPC 的指令来判定是否处于虚拟机之中.</li><li><a href="/addition/ThwartingVMDetection_Liston_Skoudis.pdf">ThwartingVMDetection_Liston_Skoudis</a> 这是一篇来自@SANS的 PDF 文档, 里面介绍了很多检测方法, 这个 pdf 应该是上述看雪文章的源头.*</li><li><a href="https://bbs.pediy.com/thread-119969.htm" target="_blank" rel="external">虚拟机检测技术剖析</a></li><li><a href="http://faq.sanbarrow.com/index.php?action=artikel&amp;cat=18&amp;id=58" target="_blank" rel="external">How to hide being inside a VM</a></li><li><a href="https://gist.github.com/oXnMe/84bf22ece3c6f483b37294ec9267c840." target="_blank" rel="external">github 上面一个设置 VMware 逃逸虚拟机检测的配置文件</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录一下各种虚拟机检测的手段&quot;&gt;&lt;a href=&quot;#记录一下各种虚拟机检测的手段&quot; class=&quot;headerlink&quot; title=&quot;记录一下各种虚拟机检测的手段&quot;&gt;&lt;/a&gt;记录一下各种虚拟机检测的手段&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="hack" scheme="http://MBTimY.github.io/tags/hack/"/>
    
      <category term="binary" scheme="http://MBTimY.github.io/tags/binary/"/>
    
  </entry>
  
  <entry>
    <title>一些不错的技术网站</title>
    <link href="http://MBTimY.github.io/2017/09/14/collectforum/"/>
    <id>http://MBTimY.github.io/2017/09/14/collectforum/</id>
    <published>2017-09-14T06:04:51.000Z</published>
    <updated>2017-09-25T20:08:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这里收集一些我经常会逛的技术的论坛"><a href="#这里收集一些我经常会逛的技术的论坛" class="headerlink" title="这里收集一些我经常会逛的技术的论坛"></a>这里收集一些我经常会逛的技术的论坛</h2><h3 id="论坛列表"><a href="#论坛列表" class="headerlink" title="论坛列表"></a>论坛列表</h3><ul><li><a href="https://forum.tuts4you.com/" target="_blank" rel="external">tut4you</a> 一个专攻于2进制逆向,crack 的论坛</li><li><a href="http://openrce.org/" target="_blank" rel="external">openrce</a> 一个活跃的逆向工程社区</li><li><a href="http://www.woodmann.com/forum/forum.php" target="_blank" rel="external">woodman</a> OPENRCE的论坛</li></ul><h3 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表"></a>工具列表</h3><ul><li><a href="https://github.com/x64dbg/x64dbg/wiki/Plugins" target="_blank" rel="external">x64dbg plugins</a> x64plugin 的一个发布页面, 可以找到大量的 x64dbg 插件很好的服务于动态 debug 中遇到的一些问题. </li><li><a href="https://www.hex-rays.com/products/ida/support/download.shtml" target="_blank" rel="external">IDAPro Plugins 官方下载中心</a></li><li><a href="http://www.openrce.org/downloads/" target="_blank" rel="external">IDAPro Plugins OpenRCE下载中心</a></li></ul><h3 id="优秀博客"><a href="#优秀博客" class="headerlink" title="优秀博客"></a>优秀博客</h3><ul><li><a href="http://www.hexblog.com/" target="_blank" rel="external">ILFAK 的博客</a> IFLAK IDA插件作者的博客,里面有很多优秀的 IDA 的东西</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;这里收集一些我经常会逛的技术的论坛&quot;&gt;&lt;a href=&quot;#这里收集一些我经常会逛的技术的论坛&quot; class=&quot;headerlink&quot; title=&quot;这里收集一些我经常会逛的技术的论坛&quot;&gt;&lt;/a&gt;这里收集一些我经常会逛的技术的论坛&lt;/h2&gt;&lt;h3 id=&quot;论坛列表&quot;
      
    
    </summary>
    
    
      <category term="hack" scheme="http://MBTimY.github.io/tags/hack/"/>
    
      <category term="binary" scheme="http://MBTimY.github.io/tags/binary/"/>
    
  </entry>
  
  <entry>
    <title>markdown 工具汇总</title>
    <link href="http://MBTimY.github.io/2017/09/14/markdowntricks/"/>
    <id>http://MBTimY.github.io/2017/09/14/markdowntricks/</id>
    <published>2017-09-13T19:40:38.000Z</published>
    <updated>2017-09-13T19:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇总一些-markdown-相关的工具汇总"><a href="#汇总一些-markdown-相关的工具汇总" class="headerlink" title="汇总一些 markdown 相关的工具汇总"></a>汇总一些 markdown 相关的工具汇总</h1><h3 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表"></a>工具列表</h3><ul><li><a href="http://markdowntables.mrvautin.com/" target="_blank" rel="external">html 表格转 markdown 表格工具</a> 这个工具可以很方便的将 html 格式的表格转换成 markdown 格式的表格</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;汇总一些-markdown-相关的工具汇总&quot;&gt;&lt;a href=&quot;#汇总一些-markdown-相关的工具汇总&quot; class=&quot;headerlink&quot; title=&quot;汇总一些 markdown 相关的工具汇总&quot;&gt;&lt;/a&gt;汇总一些 markdown 相关的工具汇总&lt;/
      
    
    </summary>
    
    
      <category term="markdown" scheme="http://MBTimY.github.io/tags/markdown/"/>
    
      <category term="tools" scheme="http://MBTimY.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>8086汇编指令速查</title>
    <link href="http://MBTimY.github.io/2017/09/14/8086assemblerdirective/"/>
    <id>http://MBTimY.github.io/2017/09/14/8086assemblerdirective/</id>
    <published>2017-09-13T16:21:29.000Z</published>
    <updated>2017-09-13T19:59:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8086汇编指令集的一些简单汇总-方便review"><a href="#8086汇编指令集的一些简单汇总-方便review" class="headerlink" title="8086汇编指令集的一些简单汇总(方便review)"></a>8086汇编指令集的一些简单汇总(方便review)</h2><h3 id="汇总的缘由"><a href="#汇总的缘由" class="headerlink" title="汇总的缘由"></a>汇总的缘由</h3><p>关于 inter 的这套指令集, 在平时的逆向工作中经常用到, 这里我收集一些指令集的网页和指令集的信息, 方便日后的工作.</p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><ul><li><a href="http://x86.renejeschke.de" target="_blank" rel="external">http://x86.renejeschke.de/</a> 这个网站基本上囊括了所有常见的指令的描述,非常方便</li></ul><h3 id="指令速查表"><a href="#指令速查表" class="headerlink" title="指令速查表"></a>指令速查表</h3><p>下面是<a href="http://x86.renejeschke.de" target="_blank" rel="external">http://x86.renejeschke.de/</a>指令表的一个简单的复制, 方便查找</p><table><thead><tr><th>Opcode</th><th>Description</th></tr></thead><tbody><tr><td>AAA</td><td>ASCII Adjust After Addition</td></tr><tr><td>AAD</td><td>ASCII Adjust AX Before Division</td></tr><tr><td>AAS</td><td>ASCII Adjust AL After Subtraction</td></tr><tr><td>ADC</td><td>Add with Carry</td></tr><tr><td>ADD</td><td>Add</td></tr><tr><td>ADDPD</td><td>Add Packed Double-Precision Floating-Point Values</td></tr><tr><td>ADDPS</td><td>Add Packed Single-Precision Floating-Point Values</td></tr><tr><td>ADDSD</td><td>Add Scalar Double-Precision Floating-Point Values</td></tr><tr><td>ADDSS</td><td>Add Scalar Single-Precision Floating-Point Values</td></tr><tr><td>ADDSUBPD</td><td>Packed Double-FP Add/Subtract</td></tr><tr><td>ADDSUBPS</td><td>Packed Single-FP Add/Subtract</td></tr><tr><td>AND</td><td>Logical AND</td></tr><tr><td>ANDPD</td><td>Bitwise Logical AND of Packed Double-Precision Floating-Point Values</td></tr><tr><td>ANDPS</td><td>Bitwise Logical AND of Packed Single-Precision Floating-Point Values</td></tr><tr><td>ANDNPD</td><td>Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values</td></tr><tr><td>ANDNPS</td><td>Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values</td></tr><tr><td>ARPL</td><td>Adjust RPL Field of Segment Selector</td></tr><tr><td>BOUND</td><td>Check Array Index Against Bounds</td></tr><tr><td>BSF</td><td>Bit Scan Forward</td></tr><tr><td>BSR</td><td>Bit Scan Reverse</td></tr><tr><td>BSWAP</td><td>Byte Swap</td></tr><tr><td>BT</td><td>Bit Test</td></tr><tr><td>BTC</td><td>Bit Test and Complement</td></tr><tr><td>BTR</td><td>Bit Test and Reset</td></tr><tr><td>BTS</td><td>Bit Test and Set</td></tr><tr><td>CALL</td><td>Call Procedure</td></tr><tr><td>CBW/CWDE</td><td>Convert Byte to Word/Convert Word to Doubleword</td></tr><tr><td>CLC</td><td>Clear Carry Flag</td></tr><tr><td>CLD</td><td>Clear Direction Flag</td></tr><tr><td>CLFLUSH</td><td>Flush Cache Line</td></tr><tr><td>CLI</td><td>Clear Interrupt Flag</td></tr><tr><td>CLTS</td><td>Clear Task-Switched Flag in CR0</td></tr><tr><td>CMC</td><td>Complement Carry Flag</td></tr><tr><td>CMOVcc</td><td>Conditional Move</td></tr><tr><td>CMP</td><td>Compare Two Operands</td></tr><tr><td>CMPPD</td><td>Compare Packed Double-Precision Floating-Point Values</td></tr><tr><td>CMPPS</td><td>Compare Packed Single-Precision Floating-Point Values</td></tr><tr><td>CMPS/CMPSB/CMPSW/CMPSD</td><td>Compare String Operands</td></tr><tr><td>CMPSD</td><td>Compare Scalar Double-Precision Floating-Point Values</td></tr><tr><td>CMPSS</td><td>Compare Scalar Single-Precision Floating-Point Values</td></tr><tr><td>CMPXCHG</td><td>Compare and Exchange</td></tr><tr><td>CMPXCHG8B</td><td>Compare and Exchange 8 Bytes</td></tr><tr><td>COMISD</td><td>Compare Scalar Ordered Double-Precision Floating- Point Values and Set EFLAGS</td></tr><tr><td>COMISS</td><td>Compare Scalar Ordered Single-Precision Floating- Point Values and Set EFLAGS</td></tr><tr><td>CPUID</td><td>CPU Identification</td></tr><tr><td>CVTDQ2PD</td><td>Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values</td></tr><tr><td>CVTDQ2PS</td><td>Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values</td></tr><tr><td>CVTPD2DQ</td><td>Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTPD2PI</td><td>Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTPD2PS</td><td>Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values</td></tr><tr><td>CVTPI2PD</td><td>Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values</td></tr><tr><td>CVTPI2PS</td><td>Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values</td></tr><tr><td>CVTPS2DQ</td><td>Convert Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTPS2PD</td><td>Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values</td></tr><tr><td>CVTPS2PI</td><td>Convert Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTSD2SI</td><td>Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer</td></tr><tr><td>CVTSD2SS</td><td>Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value</td></tr><tr><td>CVTSI2SD</td><td>Convert Doubleword Integer to Scalar Double- Precision Floating-Point Value</td></tr><tr><td>CVTSI2SS</td><td>Convert Doubleword Integer to Scalar Single- Precision Floating-Point Value</td></tr><tr><td>CVTSS2SD</td><td>Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value</td></tr><tr><td>CVTSS2SI</td><td>Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer</td></tr><tr><td>CVTTPD2PI</td><td>Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTTPD2DQ</td><td>Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTTPS2DQ</td><td>Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTTPS2PI</td><td>Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTTSD2SI</td><td>Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Doubleword Integer</td></tr><tr><td>CVTTSS2SI</td><td>Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer</td></tr><tr><td>CWD/CDQ</td><td>Convert Word to Doubleword/Convert Doubleword to Quadword</td></tr><tr><td>DAA</td><td>Decimal Adjust AL after Addition</td></tr><tr><td>DAS</td><td>Decimal Adjust AL after Subtraction</td></tr><tr><td>DEC</td><td>Decrement by 1</td></tr><tr><td>DIV</td><td>Unsigned Divide</td></tr><tr><td>DIVPD</td><td>Divide Packed Double-Precision Floating-Point Values</td></tr><tr><td>DIVPS</td><td>Divide Packed Single-Precision Floating-Point Values</td></tr><tr><td>DIVSD</td><td>Divide Scalar Double-Precision Floating-Point Values</td></tr><tr><td>DIVSS</td><td>Divide Scalar Single-Precision Floating-Point Values</td></tr><tr><td>EMMS</td><td>Empty MMX Technology State</td></tr><tr><td>ENTER</td><td>Make Stack Frame for Procedure Parameters</td></tr><tr><td>F2XM1</td><td>Compute 2x-1</td></tr><tr><td>FABS</td><td>Absolute Value</td></tr><tr><td>FADD/FADDP/FIADD</td><td>Add</td></tr><tr><td>FBLD</td><td>Load Binary Coded Decimal</td></tr><tr><td>FBSTP</td><td>Store BCD Integer and Pop</td></tr><tr><td>FCHS</td><td>Change Sign</td></tr><tr><td>FCLEX/FNCLEX</td><td>Clear Exceptions</td></tr><tr><td>FCMOVcc</td><td>Floating-Point Conditional Move</td></tr><tr><td>FCOM/FCOMP/FCOMPP</td><td>Compare Floating Point Values</td></tr><tr><td>FCOMI/FCOMIP/FUCOMI/FUCOMIP</td><td>Compare Floating Point Values and Set EFLAGS</td></tr><tr><td>FCOS</td><td>Cosine</td></tr><tr><td>FDECSTP</td><td>Decrement Stack-Top Pointer</td></tr><tr><td>FDIV/FDIVP/FIDIV</td><td>Divide</td></tr><tr><td>FDIVR/FDIVRP/FIDIVR</td><td>Reverse Divide</td></tr><tr><td>FFREE</td><td>Free Floating-Point Register</td></tr><tr><td>FICOM/FICOMP</td><td>Compare Integer</td></tr><tr><td>FILD</td><td>Load Integer</td></tr><tr><td>FINCSTP</td><td>Increment Stack-Top Pointer</td></tr><tr><td>FINIT/FNINIT</td><td>Initialize Floating-Point Unit</td></tr><tr><td>FIST/FISTP</td><td>Store Integer</td></tr><tr><td>FISTTP</td><td>Store Integer with Truncation</td></tr><tr><td>FLD</td><td>Load Floating Point Value</td></tr><tr><td>FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ</td><td>Load Constant</td></tr><tr><td>FLDCW</td><td>Load x87 FPU Control Word</td></tr><tr><td>FLDENV</td><td>Load x87 FPU Environment</td></tr><tr><td>FMUL/FMULP/FIMUL</td><td>Multiply</td></tr><tr><td>FNOP</td><td>No operation</td></tr><tr><td>FPATAN</td><td>Partial Arctangent</td></tr><tr><td>FPREM</td><td>Partial Remainder</td></tr><tr><td>FPREM1</td><td>Partial Remainder</td></tr><tr><td>FPTAN</td><td>Partial Tangent</td></tr><tr><td>FRNDINT</td><td>Round to Integer</td></tr><tr><td>FRSTOR</td><td>Restore x87 FPU State</td></tr><tr><td>FSAVE/FNSAVE</td><td>Store x87 FPU State</td></tr><tr><td>FSCALE</td><td>Scale</td></tr><tr><td>FSIN</td><td>Sine</td></tr><tr><td>FSINCOS</td><td>Sine and Cosine</td></tr><tr><td>FSQRT</td><td>Square Root</td></tr><tr><td>FST/FSTP</td><td>Store Floating Point Value</td></tr><tr><td>FSTCW/FNSTCW</td><td>Store x87 FPU Control Word</td></tr><tr><td>FSTENV/FNSTENV</td><td>Store x87 FPU Environment</td></tr><tr><td>FSTSW/FNSTSW</td><td>Store x87 FPU Status Word</td></tr><tr><td>FSUB/FSUBP/FISUB</td><td>Subtract</td></tr><tr><td>FSUBR/FSUBRP/FISUBR</td><td>Reverse Subtract</td></tr><tr><td>FTST</td><td>Test Floating Point Value</td></tr><tr><td>FUCOM/FUCOMP/FUCOMPP</td><td>Unordered Compare Floating Point Values</td></tr><tr><td>FXAM</td><td>Examine Floating Point Value</td></tr><tr><td>FXCH</td><td>Exchange Register Contents</td></tr><tr><td>FXRSTOR</td><td>Restore x87 FPU, MMX Technology, SSE, and SSE2 State</td></tr><tr><td>FXSAVE</td><td>Save x87 FPU, MMX Technology, SSE, and SSE2 State</td></tr><tr><td>FXTRACT</td><td>Extract Exponent and Mantissa</td></tr><tr><td>FYL2X</td><td>Compute y * log_2(x)</td></tr><tr><td>FYL2XP1</td><td>Compute y * log_2(x + 1)</td></tr><tr><td>HADDPD</td><td>Packed Double-FP Horizontal Add</td></tr><tr><td>HADDPS</td><td>Packed Single-FP Horizontal Add</td></tr><tr><td>HLT</td><td>Halt</td></tr><tr><td>HSUBPD</td><td>Packed Double-FP Horizontal Subtract</td></tr><tr><td>HSUBPS</td><td>Packed Single-FP Horizontal Subtract</td></tr><tr><td>IDIV</td><td>Signed Divide</td></tr><tr><td>IMUL</td><td>Signed Multiply</td></tr><tr><td>IN</td><td>Input from Port</td></tr><tr><td>INC</td><td>Increment by 1</td></tr><tr><td>INS/INSB/INSW/INSD</td><td>Input from Port to String</td></tr><tr><td>INT n/INTO/INT 3</td><td>Call to Interrupt Procedure</td></tr><tr><td>INVD</td><td>Invalidate Internal Caches</td></tr><tr><td>INVLPG</td><td>Invalidate TLB Entry</td></tr><tr><td>IRET/IRETD</td><td>Interrupt Return</td></tr><tr><td>Jcc</td><td>Jump if Condition Is Met</td></tr><tr><td>JMP</td><td>Jump</td></tr><tr><td>LAHF</td><td>Load Status Flags into AH Register</td></tr><tr><td>LAR</td><td>Load Access Rights Byte</td></tr><tr><td>LDDQU</td><td>Load Unaligned Integer 128 Bits</td></tr><tr><td>LDMXCSR</td><td>Load MXCSR Register</td></tr><tr><td>LDS/LES/LFS/LGS/LSS</td><td>Load Far Pointer</td></tr><tr><td>LEA</td><td>Load Effective Address</td></tr><tr><td>LEAVE</td><td>High Level Procedure Exit</td></tr><tr><td>LFENCE</td><td>Load Fence</td></tr><tr><td>LGDT/LIDT</td><td>Load Global/Interrupt Descriptor Table Register</td></tr><tr><td>LLDT</td><td>Load Local Descriptor Table Register</td></tr><tr><td>LMSW</td><td>Load Machine Status Word</td></tr><tr><td>LOCK</td><td>Assert LOCK# Signal Prefix</td></tr><tr><td>LODS/LODSB/LODSW/LODSD</td><td>Load String</td></tr><tr><td>LOOP/LOOPcc</td><td>Loop According to ECX Counter</td></tr><tr><td>LSL</td><td>Load Segment Limit</td></tr><tr><td>LTR</td><td>Load Task Register</td></tr><tr><td>MASKMOVDQU</td><td>Store Selected Bytes of Double Quadword</td></tr><tr><td>MASKMOVQ</td><td>Store Selected Bytes of Quadword</td></tr><tr><td>MAXPD</td><td>Return Maximum Packed Double-Precision Floating- Point Values</td></tr><tr><td>MAXPS</td><td>Return Maximum Packed Single-Precision Floating-Point Values</td></tr><tr><td>MAXSD</td><td>Return Maximum Scalar Double-Precision Floating-Point Value</td></tr><tr><td>MAXSS</td><td>Return Maximum Scalar Single-Precision Floating-Point Value</td></tr><tr><td>MFENCE</td><td>Memory Fence</td></tr><tr><td>MINPD</td><td>Return Minimum Packed Double-Precision Floating-Point Values</td></tr><tr><td>MINPS</td><td>Return Minimum Packed Single-Precision Floating-Point Values</td></tr><tr><td>MINSD</td><td>Return Minimum Scalar Double-Precision Floating-Point Value</td></tr><tr><td>MINSS</td><td>Return Minimum Scalar Single-Precision Floating-Point Value</td></tr><tr><td>MONITOR</td><td>Setup Monitor Address</td></tr><tr><td>MOV</td><td>Move</td></tr><tr><td>MOV</td><td>Move to/from Control Registers</td></tr><tr><td>MOV</td><td>Move to/from Debug Registers</td></tr><tr><td>MOVAPD</td><td>Move Aligned Packed Double-Precision Floating-Point Values</td></tr><tr><td>MOVAPS</td><td>Move Aligned Packed Single-Precision Floating-Point Values</td></tr><tr><td>MOVD</td><td>Move Doubleword</td></tr><tr><td>MOVDDUP</td><td>Move One Double-FP and Duplicate</td></tr><tr><td>MOVDQA</td><td>Move Aligned Double Quadword</td></tr><tr><td>MOVDQU</td><td>Move Unaligned Double Quadword</td></tr><tr><td>MOVDQ2Q</td><td>Move Quadword from XMM to MMX Technology Register</td></tr><tr><td>MOVHLPS</td><td>Move Packed Single-Precision Floating-Point Values High to Low</td></tr><tr><td>MOVHPD</td><td>Move High Packed Double-Precision Floating-Point Value</td></tr><tr><td>MOVHPS</td><td>Move High Packed Single-Precision Floating-Point Values</td></tr><tr><td>MOVLHPS</td><td>Move Packed Single-Precision Floating-Point Values Low to High</td></tr><tr><td>MOVLPD</td><td>Move Low Packed Double-Precision Floating-Point Value</td></tr><tr><td>MOVLPS</td><td>Move Low Packed Single-Precision Floating-Point Values</td></tr><tr><td>MOVMSKPD</td><td>Extract Packed Double-Precision Floating-Point Sign Mask</td></tr><tr><td>MOVMSKPS</td><td>Extract Packed Single-Precision Floating-Point Sign Mask</td></tr><tr><td>MOVNTDQ</td><td>Store Double Quadword Using Non-Temporal Hint</td></tr><tr><td>MOVNTI</td><td>Store Doubleword Using Non-Temporal Hint</td></tr><tr><td>MOVNTPD</td><td>Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint</td></tr><tr><td>MOVNTPS</td><td>Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint</td></tr><tr><td>MOVNTQ</td><td>Store of Quadword Using Non-Temporal Hint</td></tr><tr><td>MOVSHDUP</td><td>Move Packed Single-FP High and Duplicate</td></tr><tr><td>MOVSLDUP</td><td>Move Packed Single-FP Low and Duplicate</td></tr><tr><td>MOVQ</td><td>Move Quadword</td></tr><tr><td>MOVQ2DQ</td><td>Move Quadword from MMX Technology to XMM Register</td></tr><tr><td>MOVS/MOVSB/MOVSW/MOVSD</td><td>Move Data from String to String</td></tr><tr><td>MOVSD</td><td>Move Scalar Double-Precision Floating-Point Value</td></tr><tr><td>MOVSS</td><td>Move Scalar Single-Precision Floating-Point Values</td></tr><tr><td>MOVSX</td><td>Move with Sign-Extension</td></tr><tr><td>MOVUPD</td><td>Move Unaligned Packed Double-Precision Floating- Point Values</td></tr><tr><td>MOVUPS</td><td>Move Unaligned Packed Single-Precision Floating- Point Values</td></tr><tr><td>MOVZX</td><td>Move with Zero-Extend</td></tr><tr><td>MUL</td><td>Unsigned Multiply</td></tr><tr><td>MULPD</td><td>Multiply Packed Double-Precision Floating-Point Values</td></tr><tr><td>MULPS</td><td>Multiply Packed Single-Precision Floating-Point Values</td></tr><tr><td>MULSD</td><td>Multiply Scalar Double-Precision Floating-Point Values</td></tr><tr><td>MULSS</td><td>Multiply Scalar Single-Precision Floating-Point Values</td></tr><tr><td>MWAIT</td><td>Monitor Wait</td></tr><tr><td>NEG</td><td>Two’s Complement Negation</td></tr><tr><td>NOP</td><td>No Operation</td></tr><tr><td>NOT</td><td>One’s Complement Negation</td></tr><tr><td>OR</td><td>Logical Inclusive OR</td></tr><tr><td>ORPD</td><td>Bitwise Logical OR of Double-Precision Floating-Point Values</td></tr><tr><td>ORPS</td><td>Bitwise Logical OR of Single-Precision Floating-Point Values</td></tr><tr><td>OUT</td><td>Output to Port</td></tr><tr><td>OUTS/OUTSB/OUTSW/OUTSD</td><td>Output String to Port</td></tr><tr><td>PACKSSWB/PACKSSDW</td><td>Pack with Signed Saturation</td></tr><tr><td>PACKUSWB</td><td>Pack with Unsigned Saturation</td></tr><tr><td>PADDB/PADDW/PADDD</td><td>Add Packed Integers</td></tr><tr><td>PADDQ</td><td>Add Packed Quadword Integers</td></tr><tr><td>PADDSB/PADDSW</td><td>Add Packed Signed Integers with Signed Saturation</td></tr><tr><td>PADDUSB/PADDUSW</td><td>Add Packed Unsigned Integers with Unsigned Saturation</td></tr><tr><td>PAND</td><td>Logical AND</td></tr><tr><td>PANDN</td><td>Logical AND NOT</td></tr><tr><td>PAUSE</td><td>Spin Loop Hint</td></tr><tr><td>PAVGB/PAVGW</td><td>Average Packed Integers</td></tr><tr><td>PCMPEQB/PCMPEQW/PCMPEQD</td><td>Compare Packed Data for Equal</td></tr><tr><td>PCMPGTB/PCMPGTW/PCMPGTD</td><td>Compare Packed Signed Integers for Greater Than</td></tr><tr><td>PEXTRW</td><td>Extract Word</td></tr><tr><td>PINSRW</td><td>Insert Word</td></tr><tr><td>PMADDWD</td><td>Multiply and Add Packed Integers</td></tr><tr><td>PMAXSW</td><td>Maximum of Packed Signed Word Integers</td></tr><tr><td>PMAXUB</td><td>Maximum of Packed Unsigned Byte Integers</td></tr><tr><td>PMINSW</td><td>Minimum of Packed Signed Word Integers</td></tr><tr><td>PMINUB</td><td>Minimum of Packed Unsigned Byte Integers</td></tr><tr><td>PMOVMSKB</td><td>Move Byte Mask</td></tr><tr><td>PMULHUW</td><td>Multiply Packed Unsigned Integers and Store High Result</td></tr><tr><td>PMULHW</td><td>Multiply Packed Signed Integers and Store High Result</td></tr><tr><td>PMULLW</td><td>Multiply Packed Signed Integers and Store Low Result</td></tr><tr><td>PMULUDQ</td><td>Multiply Packed Unsigned Doubleword Integers</td></tr><tr><td>POP</td><td>Pop a Value from the Stack</td></tr><tr><td>POPA/POPAD</td><td>Pop All General-Purpose Registers</td></tr><tr><td>POPF/POPFD</td><td>Pop Stack into EFLAGS Register</td></tr><tr><td>POR</td><td>Bitwise Logical OR</td></tr><tr><td>PREFETCHh</td><td>Prefetch Data Into Caches</td></tr><tr><td>PSADBW</td><td>Compute Sum of Absolute Differences</td></tr><tr><td>PSHUFD</td><td>Shuffle Packed Doublewords</td></tr><tr><td>PSHUFHW</td><td>Shuffle Packed High Words</td></tr><tr><td>PSHUFLW</td><td>Shuffle Packed Low Words</td></tr><tr><td>PSHUFW</td><td>Shuffle Packed Words</td></tr><tr><td>PSLLDQ</td><td>Shift Double Quadword Left Logical</td></tr><tr><td>PSLLW/PSLLD/PSLLQ</td><td>Shift Packed Data Left Logical</td></tr><tr><td>PSRAW/PSRAD</td><td>Shift Packed Data Right Arithmetic</td></tr><tr><td>PSRLDQ</td><td>Shift Double Quadword Right Logical</td></tr><tr><td>PSRLW/PSRLD/PSRLQ</td><td>Shift Packed Data Right Logical</td></tr><tr><td>PSUBB/PSUBW/PSUBD</td><td>Subtract Packed Integers</td></tr><tr><td>PSUBQ</td><td>Subtract Packed Quadword Integers</td></tr><tr><td>PSUBSB/PSUBSW</td><td>Subtract Packed Signed Integers with Signed Saturation</td></tr><tr><td>PSUBUSB/PSUBUSW</td><td>Subtract Packed Unsigned Integers with Unsigned Saturation</td></tr><tr><td>PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ</td><td>Unpack High Data</td></tr><tr><td>PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ</td><td>Unpack Low Data</td></tr><tr><td>PUSH</td><td>Push Word or Doubleword Onto the Stack</td></tr><tr><td>PUSHA/PUSHAD</td><td>Push All General-Purpose Registers</td></tr><tr><td>PUSHF/PUSHFD</td><td>Push EFLAGS Register onto the Stack</td></tr><tr><td>PXOR</td><td>Logical Exclusive OR</td></tr><tr><td>RCL/RCR/ROL/ROR</td><td>Rotate</td></tr><tr><td>RCPPS</td><td>Compute Reciprocals of Packed Single-Precision Floating-Point Values</td></tr><tr><td>RCPSS</td><td>Compute Reciprocal of Scalar Single-Precision Floating- Point Values</td></tr><tr><td>RDMSR</td><td>Read from Model Specific Register</td></tr><tr><td>RDPMC</td><td>Read Performance-Monitoring Counters</td></tr><tr><td>RDTSC</td><td>Read Time-Stamp Counter</td></tr><tr><td>REP/REPE/REPZ/REPNE/REPNZ</td><td>Repeat String Operation Prefix</td></tr><tr><td>RET</td><td>Return from Procedure</td></tr><tr><td>RSM</td><td>Resume from System Management Mode</td></tr><tr><td>RSQRTPS</td><td>Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values</td></tr><tr><td>RSQRTSS</td><td>Compute Reciprocal of Square Root of Scalar Single- Precision Floating-Point Value</td></tr><tr><td>SAHF</td><td>Store AH into Flags</td></tr><tr><td>SAL/SAR/SHL/SHR</td><td>Shift</td></tr><tr><td>SBB</td><td>Integer Subtraction with Borrow</td></tr><tr><td>SCAS/SCASB/SCASW/SCASD</td><td>Scan String</td></tr><tr><td>SETcc</td><td>Set Byte on Condition</td></tr><tr><td>SFENCE</td><td>Store Fence</td></tr><tr><td>SGDT</td><td>Store Global Descriptor Table Register</td></tr><tr><td>SHLD</td><td>Double Precision Shift Left</td></tr><tr><td>SHRD</td><td>Double Precision Shift Right</td></tr><tr><td>SHUFPD</td><td>Shuffle Packed Double-Precision Floating-Point Values</td></tr><tr><td>SHUFPS</td><td>Shuffle Packed Single-Precision Floating-Point Values</td></tr><tr><td>SIDT</td><td>Store Interrupt Descriptor Table Register</td></tr><tr><td>SLDT</td><td>Store Local Descriptor Table Register</td></tr><tr><td>SMSW</td><td>Store Machine Status Word</td></tr><tr><td>SQRTPD</td><td>Compute Square Roots of Packed Double-Precision Floating-Point Values</td></tr><tr><td>SQRTPS</td><td>Compute Square Roots of Packed Single-Precision Floating-Point Values</td></tr><tr><td>SQRTSD</td><td>Compute Square Root of Scalar Double-Precision Floating-Point Value</td></tr><tr><td>SQRTSS</td><td>Compute Square Root of Scalar Single-Precision Floating-Point Value</td></tr><tr><td>STC</td><td>Set Carry Flag</td></tr><tr><td>STD</td><td>Set Direction Flag</td></tr><tr><td>STI</td><td>Set Interrupt Flag</td></tr><tr><td>STMXCSR</td><td>Store MXCSR Register State</td></tr><tr><td>STOS/STOSB/STOSW/STOSD</td><td>Store String</td></tr><tr><td>STR</td><td>Store Task Register</td></tr><tr><td>SUB</td><td>Subtract</td></tr><tr><td>SUBPD</td><td>Subtract Packed Double-Precision Floating-Point Values</td></tr><tr><td>SUBPS</td><td>Subtract Packed Single-Precision Floating-Point Values</td></tr><tr><td>SUBSD</td><td>Subtract Scalar Double-Precision Floating-Point Values</td></tr><tr><td>SUBSS</td><td>Subtract Scalar Single-Precision Floating-Point Values</td></tr><tr><td>SYSENTER</td><td>Fast System Call</td></tr><tr><td>SYSEXIT</td><td>Fast Return from Fast System Call</td></tr><tr><td>TEST</td><td>Logical Compare</td></tr><tr><td>UCOMISD</td><td>Unordered Compare Scalar Double-Precision Floating- Point Values and Set EFLAGS</td></tr><tr><td>UCOMISS</td><td>Unordered Compare Scalar Single-Precision Floating- Point Values and Set EFLAGS</td></tr><tr><td>UD2</td><td>Undefined Instruction</td></tr><tr><td>UNPCKHPD</td><td>Unpack and Interleave High Packed Double- Precision Floating-Point Values</td></tr><tr><td>UNPCKHPS</td><td>Unpack and Interleave High Packed Single-Precision Floating-Point Values</td></tr><tr><td>UNPCKLPD</td><td>Unpack and Interleave Low Packed Double-Precision Floating-Point Values</td></tr><tr><td>UNPCKLPS</td><td>Unpack and Interleave Low Packed Single-Precision Floating-Point Values</td></tr><tr><td>VERR/VERW</td><td>Verify a Segment for Reading or Writing</td></tr><tr><td>WAIT/FWAIT</td><td>Wait</td></tr><tr><td>WBINVD</td><td>Write Back and Invalidate Cache</td></tr><tr><td>WRMSR</td><td>Write to Model Specific Register</td></tr><tr><td>XADD</td><td>Exchange and Add</td></tr><tr><td>XCHG</td><td>Exchange Register/Memory with Register</td></tr><tr><td>XLAT/XLATB</td><td>Table Look-up Translation</td></tr><tr><td>XOR</td><td>Logical Exclusive OR</td></tr><tr><td>XORPD</td><td>Bitwise Logical XOR for Double-Precision Floating-Point Values</td></tr><tr><td>XORPS</td><td>Bitwise Logical XOR for Single-Precision Floating-Point Values</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;8086汇编指令集的一些简单汇总-方便review&quot;&gt;&lt;a href=&quot;#8086汇编指令集的一些简单汇总-方便review&quot; class=&quot;headerlink&quot; title=&quot;8086汇编指令集的一些简单汇总(方便review)&quot;&gt;&lt;/a&gt;8086汇编指令集的
      
    
    </summary>
    
    
      <category term="assembler" scheme="http://MBTimY.github.io/tags/assembler/"/>
    
      <category term="8086" scheme="http://MBTimY.github.io/tags/8086/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://MBTimY.github.io/2017/09/11/hello-world/"/>
    <id>http://MBTimY.github.io/2017/09/11/hello-world/</id>
    <published>2017-09-10T21:21:28.000Z</published>
    <updated>2017-09-13T15:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="first" scheme="http://MBTimY.github.io/tags/first/"/>
    
  </entry>
  
</feed>
