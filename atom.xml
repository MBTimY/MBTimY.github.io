<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimY Blog</title>
  
  <subtitle>穷则变 变则通 通则久</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://MBTimY.github.io/"/>
  <updated>2017-09-24T09:46:34.000Z</updated>
  <id>http://MBTimY.github.io/</id>
  
  <author>
    <name>TimY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VMDetect</title>
    <link href="http://MBTimY.github.io/2017/09/24/VMDetect/"/>
    <id>http://MBTimY.github.io/2017/09/24/VMDetect/</id>
    <published>2017-09-23T20:50:34.000Z</published>
    <updated>2017-09-24T09:46:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录一下各种虚拟机检测的手段"><a href="#记录一下各种虚拟机检测的手段" class="headerlink" title="记录一下各种虚拟机检测的手段"></a>记录一下各种虚拟机检测的手段</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>根据所看的 <em>IDAPRO权威指南</em> 这本书中的一些关于 VM 反检测的连接,这里整合一下现有的一些 VM 反检测手段, 方便自己方便大家.</p><h3 id="第一招-redpill-红丸"><a href="#第一招-redpill-红丸" class="headerlink" title="第一招 redpill(红丸)"></a>第一招 redpill(红丸)</h3><p><em>talk is cheap, show me code</em> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">swallow_redpill</span> <span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> m[<span class="number">2</span>+<span class="number">4</span>], rpill[] = <span class="string">"\x0f\x01\x0d\x00\x00\x00\x00\xc3"</span>;</div><div class="line">   *((<span class="keyword">unsigned</span>*)&amp;rpill[<span class="number">3</span>]) = (<span class="keyword">unsigned</span>)m;</div><div class="line">   ((<span class="keyword">void</span>(*)())&amp;rpill)();</div><div class="line">   <span class="keyword">return</span> (m[<span class="number">5</span>]&gt;<span class="number">0xd0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>上面的代码是红丸这个技术的核心的代码, 从最后的返回值上来看主要是检测一下 m 这个变量的值是否大于0xd0, 但从结果上来说如果是大于这个值的情况该函数会判断自身处于VM 的运行环境下.<br>说完现象, 这里我们探究一下原理, 这里为了节省时间就把看雪中<a href="https://bbs.pediy.com/thread-119969.htm" target="_blank" rel="external">虚拟机检测技术剖析</a>文章中的结果直接放在下面:</p><blockquote><p>利用IDT基址检测虚拟机的方法是一种通用方式，对VMware和Virtual PC均适用。中断描述符表IDT（Interrupt Descriptor Table）用于查找处理中断时所用的软件函数，它是一个由256项组成的数据，其中每一中断对应一项函数。为了读取IDT基址，我们需要通过SIDT指令来读取IDTR（中断描述符表寄存器，用于IDT在内存中的基址），SIDT指令是以如下格式来存储IDTR的内容：由于只存在一个IDTR，但又存在两个操作系统，即虚拟机系统和真主机系统。为了防止发生冲突，VMM（虚拟机监控器）必须更改虚拟机中的IDT地址，利用真主机与虚拟机环境中执行sidt指令的差异即可用于检测虚拟机是否存在。著名的“红丸”（redpill）正是利用此原理来检测VMware的。Redpill作者在VMware上发现虚拟机系统上的IDT地址通常位于0xFFXXXXXX，而Virtual PC通常位于0xE8XXXXXX，而在真实主机上正如图2所示都位于0x80xxxxxx。Redpill仅仅是通过判断执行SIDT指令后返回的第一字节是否大于0xD0，若是则说明它处于虚拟机，否则处于真实主机中。</p></blockquote><h3 id="第二招-特权指令-in-r32-r16-针对-VMware"><a href="#第二招-特权指令-in-r32-r16-针对-VMware" class="headerlink" title="第二招 特权指令 in r32, r16 (针对 VMware)"></a>第二招 特权指令 in r32, r16 (针对 VMware)</h3><p><em>talk is cheap, show me code</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsInsideVMWare</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">bool</span> rc = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">  __try</div><div class="line">  &#123;</div><div class="line">    __asm</div><div class="line">    &#123;</div><div class="line">      push   edx</div><div class="line">      push   ecx</div><div class="line">      push   ebx</div><div class="line"> </div><div class="line">      mov    eax, 'VMXh'</div><div class="line">      mov    ebx, <span class="number">0</span>  <span class="comment">// 将ebx设置为非幻数’VMXH’的其它值</span></div><div class="line">      mov    ecx, <span class="number">10</span> <span class="comment">// 指定功能号，用于获取VMWare版本，当它为0x14时用于获取VMware内存大小</span></div><div class="line">      mov    edx, 'VX' // 端口号</div><div class="line">      in     eax, dx <span class="comment">// 从端口dx读取VMware版本到eax</span></div><div class="line"><span class="comment">//若上面指定功能号为0x14时，可通过判断eax中的值是否大于0，若是则说明处于虚拟机中</span></div><div class="line">      cmp    ebx, 'VMXh' // 判断ebx中是否包含VMware版本’VMXh’，若是则在虚拟机中</div><div class="line">      setz   [rc] <span class="comment">// 设置返回值</span></div><div class="line"> </div><div class="line">      pop    ebx</div><div class="line">      pop    ecx</div><div class="line">      pop    edx</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  __except(EXCEPTION_EXECUTE_HANDLER)  <span class="comment">//如果未处于VMware中，则触发此异常</span></div><div class="line">  &#123;</div><div class="line">    rc = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码摘至第一招中描述的那篇文章中, 这里继续引用文章中原理的部分简单的说明一下为什么这段代码 可以起到检测虚拟机的神奇作用.</p><blockquote><p>Vmware为真主机与虚拟机之间提供了相互沟通的通讯机制，它使用“IN”指令来读取特定端口的数据以进行两机通讯，但由于IN指令属于特权指令，在处于保护模式下的真机上执行此指令时，除非权限允许，否则将会触发类型为“EXCEPTION_PRIV_INSTRUCTION”的异常，而在虚拟机中并不会发生异常，在指定功能号0A（获取VMware版本）的情况下，它会在EBX中返回其版本号“VMXH”；而当功能号为0x14时，可用于获取VMware内存大小，当大于0时则说明处于虚拟机中。</p></blockquote><h3 id="第三招-利用-LDT-GDT-的地址信息来判断"><a href="#第三招-利用-LDT-GDT-的地址信息来判断" class="headerlink" title="第三招 利用 LDT/GDT 的地址信息来判断"></a>第三招 利用 LDT/GDT 的地址信息来判断</h3><p><em>talk is cheap, show me codes</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LDTDetect</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> ldt_addr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ldtr[<span class="number">2</span>];</div><div class="line"> </div><div class="line">    _asm sldt ldtr</div><div class="line">    ldt_addr = *((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)&amp;ldtr);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"LDT BaseAddr: 0x%x\n"</span>, ldt_addr);</div><div class="line"> </div><div class="line">    <span class="keyword">if</span>(ldt_addr == <span class="number">0x0000</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Native OS\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Inside VMware\n"</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GDTDetect</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> gdt_addr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> gdtr[<span class="number">4</span>];</div><div class="line"> </div><div class="line">    _asm sgdt gdtr</div><div class="line">    gdt_addr = *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)&amp;gdtr[<span class="number">2</span>]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"GDT BaseAddr:0x%x\n"</span>, gdt_addr);</div><div class="line"> </div><div class="line">    <span class="keyword">if</span>((gdt_addr &gt;&gt; <span class="number">24</span>) == <span class="number">0xff</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Inside VMware\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Native OS\n"</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    LDTDetect();</div><div class="line">    GDTDetect();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里的检测方法利用的是检测 LDT 和 GDT 这两个记录描述符表的寄存器,所存放的地址来判定的.一样, 这里我们继续引用上述中的文章的部分章节来简单的解释一下原理.</p><blockquote><p>在 《Intel® 64 and IA-32  Architecture Software Developer’s Manual Volume 3A: System Programming Guide》第二章的Vol.3 2-5 一页（我的Intel开发手册是2008版的）中对于LDT和GDT的描述如下（以下内容为个人翻译）：<br>在保护模式下，所有的内存访问都要通过全局描述符表（GDT）或者本地描述符表（LDT）才能进行。这些表包含有段描述符的调用入口。各个段描述符都包含有各段的基址，访问权限，类型和使用信息，而且每个段描述符都拥有一个与之相匹配的段选择子，各个段选择子都为软件程序提供一个GDT或LDT索引（与之相关联的段描述符偏移量），一个全局/本地标志（决定段选择子是指向GDT还是LDT），以及访问权限信息。<br>若想访问段中的某一字节，必须同时提供一个段选择子和一个偏移量。段选择子为段提供可访问的段描述符地址（在GDT 或者LDT 中）。通过段描述符，处理器从中获取段在线性地址空间里的基址，而偏移量用于确定字节地址相对基址的位置。假定处理器在当前权限级别（CPL）可访问这个段，那么通过这种机制就可以访问在GDT 或LDT 中的各种有效代码、数据或者堆栈段，这里的CPL是指当前可执行代码段的保护级别。<br>……<br>GDT的线性基址被保存在GDT寄存器（GDTR）中，而LDT的线性基址被保存在LDT寄存器（LDTR）中。 </p><p>由于虚拟机与真实主机中的GDT和LDT并不能相同，这与使用IDT的检测方法一样，因此虚拟机必须为它们提供一个“复制体”。关于GDT和LDT的基址可通过SGDT和SLDT指令获取。虚拟机检测工具Scoopy suite的作者Tobias Klein经测试发现，当LDT基址位于0x0000（只有两字节）时为真实主机，否则为虚拟机，而当GDT基址位于0xFFXXXXXX时说明处于虚拟机中，否则为真实主机。</p></blockquote><h3 id="第四招-利用-TSS-段选择器来判定"><a href="#第四招-利用-TSS-段选择器来判定" class="headerlink" title="第四招 利用 TSS 段选择器来判定"></a>第四招 利用 TSS 段选择器来判定</h3><p><em>talk is cheap, show me code</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mem[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"> </div><div class="line">    __asm str mem;</div><div class="line">    <span class="built_in">printf</span> (<span class="string">" STR base: 0x"</span>);</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%02x"</span>,mem[i]);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ( (mem[<span class="number">0</span>]==<span class="number">0x00</span>) &amp;&amp; (mem[<span class="number">1</span>]==<span class="number">0x40</span>))</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n INSIDE MATRIX!!\n"</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n Native OS!!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>原理跟上述的几个差不多, 这里利用的是 TSS 这个段选择器的地址在虚拟机和真实机的不同来判定的. 详细的原理继续引用文章中的说法:</p><blockquote><p>在保护模式下运行的所有程序在切换任务时，对于当前任务中指向TSS的段选择器将会被存储在任务寄存器中，TSS中包含有当前任务的可执行环境状态，包括通用寄存器状态，段寄存器状态，标志寄存器状态，EIP寄存器状态等等，当此项任务再次被执行时，处理器就会其原先保存的任务状态。每项任务均有其自己的TSS，而我们可以通过STR指令来获取指向当前任务中TSS的段选择器。这里STR（Store task register）指令是用于将任务寄存器 (TR) 中的段选择器存储到目标操作数，目标操作数可以是通用寄存器或内存位置，使用此指令存储的段选择器指向当前正在运行的任务的任务状态段 (TSS)。在虚拟机和真实主机之中，通过STR读取的地址是不同的，当地址等于0x0040xxxx时，说明处于虚拟机中，否则为真实主机。</p></blockquote><h3 id="第五招-利用虚拟机安装的特定软件来判定"><a href="#第五招-利用虚拟机安装的特定软件来判定" class="headerlink" title="第五招 利用虚拟机安装的特定软件来判定"></a>第五招 利用虚拟机安装的特定软件来判定</h3><p><em>talk is cheap, show me codes</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="number">.386</span></div><div class="line">.model flat, stdcall</div><div class="line">option casemap:none</div><div class="line"> </div><div class="line">   include  windows.inc</div><div class="line">   include  user32.inc</div><div class="line">   include  kernel32.inc</div><div class="line">   include  advapi32.inc</div><div class="line"> </div><div class="line">   includelib  user32.lib</div><div class="line">   includelib  kernel32.lib</div><div class="line">   includelib  advapi32.lib</div><div class="line"> </div><div class="line">.data</div><div class="line">szCaption     db <span class="string">"VMware Detector "</span>,<span class="number">0</span></div><div class="line">szInside         db <span class="string">"Inside VMware!"</span>,<span class="number">0</span></div><div class="line">szOutside              db <span class="string">"Native OS!"</span>,<span class="number">0</span></div><div class="line">szSubKey      db <span class="string">"software\VMWare, Inc.\VMware tools"</span>,<span class="number">0</span></div><div class="line">hKey              dd    ?</div><div class="line"> </div><div class="line">.code</div><div class="line">start:</div><div class="line">  invoke RegOpenKeyEx, HKEY_LOCAL_MACHINE, addr szSubKey, <span class="number">0</span>,\</div><div class="line">                 KEY_WRITE or KEY_READ, addr hKey</div><div class="line">  .if eax == ERROR_SUCCESS</div><div class="line">  invoke MessageBox, NULL,addr szInside, addr szCaption, MB_OK</div><div class="line">  .else</div><div class="line">  invoke MessageBox, NULL,addr szOutside, addr szCaption, MB_OK</div><div class="line">  .endif</div><div class="line">  invoke RegCloseKey,hKey</div><div class="line">  invoke ExitProcess,NULL</div><div class="line">end start</div></pre></td></tr></table></figure></p><p>这里简单的通过搜索注册表中是否存在”software\VMWare, Inc.\VMware tools”这个健值来判定是否处于 vmware 的虚拟机之中, 主要是因为 vmwaretool 这个工具是 vmware 特有的用于与 host 主机进行一些交互行为的软件. 这样的软件在安装的时候都会在 windows 的注册表中注册大量的与软件相关的信息, 透过这些信息来检测也是很多软件常用的行为.<br>下面罗列一些可以用来检测是否在虚拟机中的的注册表信息, 仅供参考(来自上述的看雪文章中):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">项名：HKEY_CLASSES_ROOT\Applications\VMwareHostOpen.exe</div><div class="line">项名：HKEY_CLASSES_ROOT\Installer\Products\C2A6F2EFE6910124C940B2B12CF170FE\ProductName</div><div class="line">键值“VMware Tools”</div><div class="line">项名：HKEY_CLASSES_ROOT\Installer\Products\C2A6F2EFE6910124C940B2B12CF170FE\SourceList\PackageName</div><div class="line">键值：VMware Tools.msi</div><div class="line">项名：HKEY_CURRENT_USER\Printers\DeviceOld</div><div class="line">键值：_#VMwareVirtualPrinter,winspool,TPVM:</div><div class="line">项名：HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0\Identifier</div><div class="line">键值：VMware Virtual IDE Hard Drive</div><div class="line">项名：HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 1\Scsi Bus 0\Target Id 0\Logical Unit Id 0\Identifier</div><div class="line">键值：NECVMWar VMware IDE CDR10</div><div class="line">项名：HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Installer\Products\C2A6F2EFE6910124C940B2B12CF170FE\ProductName</div><div class="line">键值：VMware Tools</div><div class="line">项名：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Products\C2A6F2EFE6910124C940B2B12CF170FE\InstallProperties\DisplayName</div><div class="line">键值：VMware Tools</div><div class="line">项名：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Reinstall\0002\DeviceDesc</div><div class="line">键值：VMware SVGA II</div><div class="line">项名：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards\2\Description</div><div class="line">键值：VMware Accelerated AMD PCNet Adapter</div><div class="line">项名：HKEY_LOCAL_MACHINE\SOFTWARE\VMware, Inc.\VMware Tools</div><div class="line">项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&#123;4D36E968-E325-11CE-BFC1-08002BE10318&#125;\0000\DriverDesc</div><div class="line">键值：VMware SVGA II</div><div class="line">项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&#123;4D36E968-E325-11CE-BFC1-08002BE10318&#125;\0000\ProviderName</div><div class="line">键值：VMware, Inc.</div><div class="line">项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&#123;4D36E972-E325-11CE-BFC1-08002bE10318&#125;\0001\DriverDesc</div><div class="line">键值：VMware Accelerated AMD PCNet Adapter</div><div class="line">项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\&#123;4D36E97B-E325-11CE-BFC1-08002BE10318&#125;\0000\DriverDesc</div><div class="line">键值：VMware SCSI Controller</div><div class="line">项名：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Print\Monitors\ThinPrint Print Port Monitor for VMWare</div></pre></td></tr></table></figure></p><h3 id="第六招-利用程序运行的时间差来检测"><a href="#第六招-利用程序运行的时间差来检测" class="headerlink" title="第六招 利用程序运行的时间差来检测"></a>第六招 利用程序运行的时间差来检测</h3><p><em>talk is cheap, show me codes</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="number">.586</span>p</div><div class="line">.model flat, stdcall</div><div class="line">option casemap:none</div><div class="line"> </div><div class="line">include         windows.inc</div><div class="line">include             kernel32.inc</div><div class="line">include         user32.inc</div><div class="line"> </div><div class="line">includelib      kernel32.lib</div><div class="line">includelib      user32.lib</div><div class="line"> </div><div class="line">             </div><div class="line">.data</div><div class="line">szTitle         db  <span class="string">"VMDetect With RDTSC"</span>, <span class="number">0</span>h</div><div class="line">szInsideVM      db  <span class="string">"Inside VMware!"</span>, <span class="number">0</span>h</div><div class="line">szOutsideVM     db  <span class="string">"Native OS!"</span>, <span class="number">0</span>h</div><div class="line"> </div><div class="line">.code</div><div class="line"> </div><div class="line">start:</div><div class="line">    RDTSC</div><div class="line">    xchg        ecx, eax</div><div class="line">    RDTSC  </div><div class="line">    sub     eax, ecx</div><div class="line">    cmp     eax, <span class="number">0</span>FFh</div><div class="line">    jg      Detected</div><div class="line">     </div><div class="line">    invoke  MessageBox, <span class="number">0</span>, offset szOutsideVM, offset szTitle, <span class="number">0</span></div><div class="line">    ret</div><div class="line">     </div><div class="line">Detected:</div><div class="line">    invoke  MessageBox, <span class="number">0</span>, offset szInsideVM, offset szTitle, <span class="number">0</span></div><div class="line">    ret</div><div class="line">end start</div></pre></td></tr></table></figure></p><p>这里用到的方法是通过判定在虚拟机和真实机之间, 对于一个相同的汇编指令 “xchg ecx,eax” 执行起来所用到的时间消耗不一致来进行检测, 不过我认为这种方法的可行性并不是特别高, 因为检测的阈值不是特别好判断, 而且用户的机器上面可能出现各种情况, 如果采用这种方法很容易误报.<br>这里记录这个方法只是为了丰富一些检测方法, 下面引用一下上述看雪文章中作者的理论:</p><blockquote><p>本方法通过运行一段特定代码，然后比较这段代码在虚拟机和真实主机之中的相对运行时间，以此来判断是否处于虚拟机之中。这段代码我们可以通过RDTSC指令来实现，RDTSC指令是用于将计算机启动以来的CPU运行周期数存放到EDX：EAX里面，其中EDX是高位，而EAX是低位。下面我们以xchg    ecx,  eax 一句指令的运行时间为例，这段指令在我的真实主机windows 7系统上的运行时间为0000001E,而该指令在虚拟机WinXP下的运行时间为00000442.</p><p>两者之间的运行时间明显差别很多，在虚拟机中的运行速度远不如真实主机的，一般情况下，当它的运行时间大于0xFF时，就可以确定它处于虚拟机之中了.</p></blockquote><h3 id="第七招-检测虚拟机中特定的硬件信息"><a href="#第七招-检测虚拟机中特定的硬件信息" class="headerlink" title="第七招 检测虚拟机中特定的硬件信息"></a>第七招 检测虚拟机中特定的硬件信息</h3><blockquote><p>Virtual machines make use of virtual hardware abstraction layers to pro- vide the interface between the virtual machine and the host computer’s native hardware. Characteristics of the virtual hardware are often easily detectable by software running within the virtual machine. For example, VMware has been assigned its own organizationally unique identifiers (OUI) 21 for use with its virtualized network adapters. Observing a VMware-specific OUI is a good indication that a program is running within a virtual machine. Note that it is usually possible to modify the MAC address assigned to virtual network adapters using configuration options on the host computer.</p><footer><strong>@the idapro book</strong></footer></blockquote><p>上面的文字描述了虚拟机检测硬件信息的基本上思想, 这种检测虚拟机硬件的特定信息的方法可能有很多种具体的实现, 主要是针对于不同的虚拟机产品.其中也包括了上述第五招用的通过注册表中的信息来检测一些特定硬件包含的字符串,下面分享两个我看见的方法:</p><ul><li><p>VMware默认的网卡MAC地址前缀为“00-05-69，00-0C-29或者00-50-56”，这前3节是由VMware分配的唯一标识符OUI，以供它的虚拟化适配器使用,通过检测前三节就可以判定自身处于虚拟机中.</p></li><li><p>还有一种检测硬盘 modal number 的方法, 可以直接在<a href="https://bbs.pediy.com/thread-110046.htm" target="_blank" rel="external">这里</a>查看</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上的方法都是出自<a href="https://bbs.pediy.com/thread-119969.htm" target="_blank" rel="external">虚拟机检测技术剖析</a>一文中,这里面包含大部分的检测虚拟机的手段.我这里写出来这些主要是为了自己以后方便查询,接下来我贴出一些 IDAPRO 中推荐的参考链接,链接中包含的检测虚拟机手段基本上在原理上面跟上述的文章中大致没有什么太大的区别,主要是针对一些不同的虚拟机产品和特定的一些指令上面有着不同.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><ul><li><a href="https://www.codeproject.com/Articles/9823/Detect-if-your-program-is-running-inside-a-Virtual" target="_blank" rel="external">Detect if your program is running inside a Virtual Machine</a> 这里演示了两种检测虚拟机的方法, 其中一种 redpill 上面的文章已经介绍, 另外一种是用来检测 VirtualPC的, 主要是针对一个特定只能运行在 VirtualPC 的指令来判定是否处于虚拟机之中.</li><li><a href="/addition/ThwartingVMDetection_Liston_Skoudis.pdf">ThwartingVMDetection_Liston_Skoudis</a> 这是一篇来自@SANS的 PDF 文档, 里面介绍了很多检测方法, 这个 pdf 应该是上述看雪文章的源头.*</li><li><a href="https://bbs.pediy.com/thread-119969.htm" target="_blank" rel="external">虚拟机检测技术剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录一下各种虚拟机检测的手段&quot;&gt;&lt;a href=&quot;#记录一下各种虚拟机检测的手段&quot; class=&quot;headerlink&quot; title=&quot;记录一下各种虚拟机检测的手段&quot;&gt;&lt;/a&gt;记录一下各种虚拟机检测的手段&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="hack" scheme="http://MBTimY.github.io/tags/hack/"/>
    
      <category term="binary" scheme="http://MBTimY.github.io/tags/binary/"/>
    
  </entry>
  
  <entry>
    <title>一些不错的技术网站</title>
    <link href="http://MBTimY.github.io/2017/09/14/collectforum/"/>
    <id>http://MBTimY.github.io/2017/09/14/collectforum/</id>
    <published>2017-09-14T06:04:51.000Z</published>
    <updated>2017-09-17T07:06:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这里收集一些我经常会逛的技术的论坛"><a href="#这里收集一些我经常会逛的技术的论坛" class="headerlink" title="这里收集一些我经常会逛的技术的论坛"></a>这里收集一些我经常会逛的技术的论坛</h2><h3 id="论坛列表"><a href="#论坛列表" class="headerlink" title="论坛列表"></a>论坛列表</h3><ul><li><a href="https://forum.tuts4you.com/" target="_blank" rel="external">tut4you</a> 一个专攻于2进制逆向,crack 的论坛</li><li><a href="http://openrce.org/" target="_blank" rel="external">openrce</a> 一个活跃的逆向工程社区</li><li><a href="http://www.woodmann.com/" target="_blank" rel="external">rceforum</a> RCE的论坛</li></ul><h3 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表"></a>工具列表</h3><ul><li><a href="https://github.com/x64dbg/x64dbg/wiki/Plugins" target="_blank" rel="external">x64dbg plugins</a> x64plugin 的一个发布页面, 可以找到大量的 x64dbg 插件很好的服务于动态 debug 中遇到的一些问题. </li></ul><h3 id="优秀博客"><a href="#优秀博客" class="headerlink" title="优秀博客"></a>优秀博客</h3><ul><li><a href="http://www.hexblog.com/" target="_blank" rel="external">ILFAK 的博客</a> IFLAK IDA插件作者的博客,里面有很多优秀的 IDA 的东西</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;这里收集一些我经常会逛的技术的论坛&quot;&gt;&lt;a href=&quot;#这里收集一些我经常会逛的技术的论坛&quot; class=&quot;headerlink&quot; title=&quot;这里收集一些我经常会逛的技术的论坛&quot;&gt;&lt;/a&gt;这里收集一些我经常会逛的技术的论坛&lt;/h2&gt;&lt;h3 id=&quot;论坛列表&quot;
      
    
    </summary>
    
    
      <category term="hack" scheme="http://MBTimY.github.io/tags/hack/"/>
    
      <category term="binary" scheme="http://MBTimY.github.io/tags/binary/"/>
    
  </entry>
  
  <entry>
    <title>markdown 工具汇总</title>
    <link href="http://MBTimY.github.io/2017/09/14/markdowntricks/"/>
    <id>http://MBTimY.github.io/2017/09/14/markdowntricks/</id>
    <published>2017-09-13T19:40:38.000Z</published>
    <updated>2017-09-13T19:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇总一些-markdown-相关的工具汇总"><a href="#汇总一些-markdown-相关的工具汇总" class="headerlink" title="汇总一些 markdown 相关的工具汇总"></a>汇总一些 markdown 相关的工具汇总</h1><h3 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表"></a>工具列表</h3><ul><li><a href="http://markdowntables.mrvautin.com/" target="_blank" rel="external">html 表格转 markdown 表格工具</a> 这个工具可以很方便的将 html 格式的表格转换成 markdown 格式的表格</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;汇总一些-markdown-相关的工具汇总&quot;&gt;&lt;a href=&quot;#汇总一些-markdown-相关的工具汇总&quot; class=&quot;headerlink&quot; title=&quot;汇总一些 markdown 相关的工具汇总&quot;&gt;&lt;/a&gt;汇总一些 markdown 相关的工具汇总&lt;/
      
    
    </summary>
    
    
      <category term="markdown" scheme="http://MBTimY.github.io/tags/markdown/"/>
    
      <category term="tools" scheme="http://MBTimY.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>8086汇编指令速查</title>
    <link href="http://MBTimY.github.io/2017/09/14/8086assemblerdirective/"/>
    <id>http://MBTimY.github.io/2017/09/14/8086assemblerdirective/</id>
    <published>2017-09-13T16:21:29.000Z</published>
    <updated>2017-09-13T19:59:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8086汇编指令集的一些简单汇总-方便review"><a href="#8086汇编指令集的一些简单汇总-方便review" class="headerlink" title="8086汇编指令集的一些简单汇总(方便review)"></a>8086汇编指令集的一些简单汇总(方便review)</h2><h3 id="汇总的缘由"><a href="#汇总的缘由" class="headerlink" title="汇总的缘由"></a>汇总的缘由</h3><p>关于 inter 的这套指令集, 在平时的逆向工作中经常用到, 这里我收集一些指令集的网页和指令集的信息, 方便日后的工作.</p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><ul><li><a href="http://x86.renejeschke.de" target="_blank" rel="external">http://x86.renejeschke.de/</a> 这个网站基本上囊括了所有常见的指令的描述,非常方便</li></ul><h3 id="指令速查表"><a href="#指令速查表" class="headerlink" title="指令速查表"></a>指令速查表</h3><p>下面是<a href="http://x86.renejeschke.de" target="_blank" rel="external">http://x86.renejeschke.de/</a>指令表的一个简单的复制, 方便查找</p><table><thead><tr><th>Opcode</th><th>Description</th></tr></thead><tbody><tr><td>AAA</td><td>ASCII Adjust After Addition</td></tr><tr><td>AAD</td><td>ASCII Adjust AX Before Division</td></tr><tr><td>AAS</td><td>ASCII Adjust AL After Subtraction</td></tr><tr><td>ADC</td><td>Add with Carry</td></tr><tr><td>ADD</td><td>Add</td></tr><tr><td>ADDPD</td><td>Add Packed Double-Precision Floating-Point Values</td></tr><tr><td>ADDPS</td><td>Add Packed Single-Precision Floating-Point Values</td></tr><tr><td>ADDSD</td><td>Add Scalar Double-Precision Floating-Point Values</td></tr><tr><td>ADDSS</td><td>Add Scalar Single-Precision Floating-Point Values</td></tr><tr><td>ADDSUBPD</td><td>Packed Double-FP Add/Subtract</td></tr><tr><td>ADDSUBPS</td><td>Packed Single-FP Add/Subtract</td></tr><tr><td>AND</td><td>Logical AND</td></tr><tr><td>ANDPD</td><td>Bitwise Logical AND of Packed Double-Precision Floating-Point Values</td></tr><tr><td>ANDPS</td><td>Bitwise Logical AND of Packed Single-Precision Floating-Point Values</td></tr><tr><td>ANDNPD</td><td>Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values</td></tr><tr><td>ANDNPS</td><td>Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values</td></tr><tr><td>ARPL</td><td>Adjust RPL Field of Segment Selector</td></tr><tr><td>BOUND</td><td>Check Array Index Against Bounds</td></tr><tr><td>BSF</td><td>Bit Scan Forward</td></tr><tr><td>BSR</td><td>Bit Scan Reverse</td></tr><tr><td>BSWAP</td><td>Byte Swap</td></tr><tr><td>BT</td><td>Bit Test</td></tr><tr><td>BTC</td><td>Bit Test and Complement</td></tr><tr><td>BTR</td><td>Bit Test and Reset</td></tr><tr><td>BTS</td><td>Bit Test and Set</td></tr><tr><td>CALL</td><td>Call Procedure</td></tr><tr><td>CBW/CWDE</td><td>Convert Byte to Word/Convert Word to Doubleword</td></tr><tr><td>CLC</td><td>Clear Carry Flag</td></tr><tr><td>CLD</td><td>Clear Direction Flag</td></tr><tr><td>CLFLUSH</td><td>Flush Cache Line</td></tr><tr><td>CLI</td><td>Clear Interrupt Flag</td></tr><tr><td>CLTS</td><td>Clear Task-Switched Flag in CR0</td></tr><tr><td>CMC</td><td>Complement Carry Flag</td></tr><tr><td>CMOVcc</td><td>Conditional Move</td></tr><tr><td>CMP</td><td>Compare Two Operands</td></tr><tr><td>CMPPD</td><td>Compare Packed Double-Precision Floating-Point Values</td></tr><tr><td>CMPPS</td><td>Compare Packed Single-Precision Floating-Point Values</td></tr><tr><td>CMPS/CMPSB/CMPSW/CMPSD</td><td>Compare String Operands</td></tr><tr><td>CMPSD</td><td>Compare Scalar Double-Precision Floating-Point Values</td></tr><tr><td>CMPSS</td><td>Compare Scalar Single-Precision Floating-Point Values</td></tr><tr><td>CMPXCHG</td><td>Compare and Exchange</td></tr><tr><td>CMPXCHG8B</td><td>Compare and Exchange 8 Bytes</td></tr><tr><td>COMISD</td><td>Compare Scalar Ordered Double-Precision Floating- Point Values and Set EFLAGS</td></tr><tr><td>COMISS</td><td>Compare Scalar Ordered Single-Precision Floating- Point Values and Set EFLAGS</td></tr><tr><td>CPUID</td><td>CPU Identification</td></tr><tr><td>CVTDQ2PD</td><td>Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values</td></tr><tr><td>CVTDQ2PS</td><td>Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values</td></tr><tr><td>CVTPD2DQ</td><td>Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTPD2PI</td><td>Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTPD2PS</td><td>Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values</td></tr><tr><td>CVTPI2PD</td><td>Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values</td></tr><tr><td>CVTPI2PS</td><td>Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values</td></tr><tr><td>CVTPS2DQ</td><td>Convert Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTPS2PD</td><td>Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values</td></tr><tr><td>CVTPS2PI</td><td>Convert Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTSD2SI</td><td>Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer</td></tr><tr><td>CVTSD2SS</td><td>Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value</td></tr><tr><td>CVTSI2SD</td><td>Convert Doubleword Integer to Scalar Double- Precision Floating-Point Value</td></tr><tr><td>CVTSI2SS</td><td>Convert Doubleword Integer to Scalar Single- Precision Floating-Point Value</td></tr><tr><td>CVTSS2SD</td><td>Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value</td></tr><tr><td>CVTSS2SI</td><td>Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer</td></tr><tr><td>CVTTPD2PI</td><td>Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTTPD2DQ</td><td>Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTTPS2DQ</td><td>Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTTPS2PI</td><td>Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Doubleword Integers</td></tr><tr><td>CVTTSD2SI</td><td>Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Doubleword Integer</td></tr><tr><td>CVTTSS2SI</td><td>Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer</td></tr><tr><td>CWD/CDQ</td><td>Convert Word to Doubleword/Convert Doubleword to Quadword</td></tr><tr><td>DAA</td><td>Decimal Adjust AL after Addition</td></tr><tr><td>DAS</td><td>Decimal Adjust AL after Subtraction</td></tr><tr><td>DEC</td><td>Decrement by 1</td></tr><tr><td>DIV</td><td>Unsigned Divide</td></tr><tr><td>DIVPD</td><td>Divide Packed Double-Precision Floating-Point Values</td></tr><tr><td>DIVPS</td><td>Divide Packed Single-Precision Floating-Point Values</td></tr><tr><td>DIVSD</td><td>Divide Scalar Double-Precision Floating-Point Values</td></tr><tr><td>DIVSS</td><td>Divide Scalar Single-Precision Floating-Point Values</td></tr><tr><td>EMMS</td><td>Empty MMX Technology State</td></tr><tr><td>ENTER</td><td>Make Stack Frame for Procedure Parameters</td></tr><tr><td>F2XM1</td><td>Compute 2x-1</td></tr><tr><td>FABS</td><td>Absolute Value</td></tr><tr><td>FADD/FADDP/FIADD</td><td>Add</td></tr><tr><td>FBLD</td><td>Load Binary Coded Decimal</td></tr><tr><td>FBSTP</td><td>Store BCD Integer and Pop</td></tr><tr><td>FCHS</td><td>Change Sign</td></tr><tr><td>FCLEX/FNCLEX</td><td>Clear Exceptions</td></tr><tr><td>FCMOVcc</td><td>Floating-Point Conditional Move</td></tr><tr><td>FCOM/FCOMP/FCOMPP</td><td>Compare Floating Point Values</td></tr><tr><td>FCOMI/FCOMIP/FUCOMI/FUCOMIP</td><td>Compare Floating Point Values and Set EFLAGS</td></tr><tr><td>FCOS</td><td>Cosine</td></tr><tr><td>FDECSTP</td><td>Decrement Stack-Top Pointer</td></tr><tr><td>FDIV/FDIVP/FIDIV</td><td>Divide</td></tr><tr><td>FDIVR/FDIVRP/FIDIVR</td><td>Reverse Divide</td></tr><tr><td>FFREE</td><td>Free Floating-Point Register</td></tr><tr><td>FICOM/FICOMP</td><td>Compare Integer</td></tr><tr><td>FILD</td><td>Load Integer</td></tr><tr><td>FINCSTP</td><td>Increment Stack-Top Pointer</td></tr><tr><td>FINIT/FNINIT</td><td>Initialize Floating-Point Unit</td></tr><tr><td>FIST/FISTP</td><td>Store Integer</td></tr><tr><td>FISTTP</td><td>Store Integer with Truncation</td></tr><tr><td>FLD</td><td>Load Floating Point Value</td></tr><tr><td>FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ</td><td>Load Constant</td></tr><tr><td>FLDCW</td><td>Load x87 FPU Control Word</td></tr><tr><td>FLDENV</td><td>Load x87 FPU Environment</td></tr><tr><td>FMUL/FMULP/FIMUL</td><td>Multiply</td></tr><tr><td>FNOP</td><td>No operation</td></tr><tr><td>FPATAN</td><td>Partial Arctangent</td></tr><tr><td>FPREM</td><td>Partial Remainder</td></tr><tr><td>FPREM1</td><td>Partial Remainder</td></tr><tr><td>FPTAN</td><td>Partial Tangent</td></tr><tr><td>FRNDINT</td><td>Round to Integer</td></tr><tr><td>FRSTOR</td><td>Restore x87 FPU State</td></tr><tr><td>FSAVE/FNSAVE</td><td>Store x87 FPU State</td></tr><tr><td>FSCALE</td><td>Scale</td></tr><tr><td>FSIN</td><td>Sine</td></tr><tr><td>FSINCOS</td><td>Sine and Cosine</td></tr><tr><td>FSQRT</td><td>Square Root</td></tr><tr><td>FST/FSTP</td><td>Store Floating Point Value</td></tr><tr><td>FSTCW/FNSTCW</td><td>Store x87 FPU Control Word</td></tr><tr><td>FSTENV/FNSTENV</td><td>Store x87 FPU Environment</td></tr><tr><td>FSTSW/FNSTSW</td><td>Store x87 FPU Status Word</td></tr><tr><td>FSUB/FSUBP/FISUB</td><td>Subtract</td></tr><tr><td>FSUBR/FSUBRP/FISUBR</td><td>Reverse Subtract</td></tr><tr><td>FTST</td><td>Test Floating Point Value</td></tr><tr><td>FUCOM/FUCOMP/FUCOMPP</td><td>Unordered Compare Floating Point Values</td></tr><tr><td>FXAM</td><td>Examine Floating Point Value</td></tr><tr><td>FXCH</td><td>Exchange Register Contents</td></tr><tr><td>FXRSTOR</td><td>Restore x87 FPU, MMX Technology, SSE, and SSE2 State</td></tr><tr><td>FXSAVE</td><td>Save x87 FPU, MMX Technology, SSE, and SSE2 State</td></tr><tr><td>FXTRACT</td><td>Extract Exponent and Mantissa</td></tr><tr><td>FYL2X</td><td>Compute y * log_2(x)</td></tr><tr><td>FYL2XP1</td><td>Compute y * log_2(x + 1)</td></tr><tr><td>HADDPD</td><td>Packed Double-FP Horizontal Add</td></tr><tr><td>HADDPS</td><td>Packed Single-FP Horizontal Add</td></tr><tr><td>HLT</td><td>Halt</td></tr><tr><td>HSUBPD</td><td>Packed Double-FP Horizontal Subtract</td></tr><tr><td>HSUBPS</td><td>Packed Single-FP Horizontal Subtract</td></tr><tr><td>IDIV</td><td>Signed Divide</td></tr><tr><td>IMUL</td><td>Signed Multiply</td></tr><tr><td>IN</td><td>Input from Port</td></tr><tr><td>INC</td><td>Increment by 1</td></tr><tr><td>INS/INSB/INSW/INSD</td><td>Input from Port to String</td></tr><tr><td>INT n/INTO/INT 3</td><td>Call to Interrupt Procedure</td></tr><tr><td>INVD</td><td>Invalidate Internal Caches</td></tr><tr><td>INVLPG</td><td>Invalidate TLB Entry</td></tr><tr><td>IRET/IRETD</td><td>Interrupt Return</td></tr><tr><td>Jcc</td><td>Jump if Condition Is Met</td></tr><tr><td>JMP</td><td>Jump</td></tr><tr><td>LAHF</td><td>Load Status Flags into AH Register</td></tr><tr><td>LAR</td><td>Load Access Rights Byte</td></tr><tr><td>LDDQU</td><td>Load Unaligned Integer 128 Bits</td></tr><tr><td>LDMXCSR</td><td>Load MXCSR Register</td></tr><tr><td>LDS/LES/LFS/LGS/LSS</td><td>Load Far Pointer</td></tr><tr><td>LEA</td><td>Load Effective Address</td></tr><tr><td>LEAVE</td><td>High Level Procedure Exit</td></tr><tr><td>LFENCE</td><td>Load Fence</td></tr><tr><td>LGDT/LIDT</td><td>Load Global/Interrupt Descriptor Table Register</td></tr><tr><td>LLDT</td><td>Load Local Descriptor Table Register</td></tr><tr><td>LMSW</td><td>Load Machine Status Word</td></tr><tr><td>LOCK</td><td>Assert LOCK# Signal Prefix</td></tr><tr><td>LODS/LODSB/LODSW/LODSD</td><td>Load String</td></tr><tr><td>LOOP/LOOPcc</td><td>Loop According to ECX Counter</td></tr><tr><td>LSL</td><td>Load Segment Limit</td></tr><tr><td>LTR</td><td>Load Task Register</td></tr><tr><td>MASKMOVDQU</td><td>Store Selected Bytes of Double Quadword</td></tr><tr><td>MASKMOVQ</td><td>Store Selected Bytes of Quadword</td></tr><tr><td>MAXPD</td><td>Return Maximum Packed Double-Precision Floating- Point Values</td></tr><tr><td>MAXPS</td><td>Return Maximum Packed Single-Precision Floating-Point Values</td></tr><tr><td>MAXSD</td><td>Return Maximum Scalar Double-Precision Floating-Point Value</td></tr><tr><td>MAXSS</td><td>Return Maximum Scalar Single-Precision Floating-Point Value</td></tr><tr><td>MFENCE</td><td>Memory Fence</td></tr><tr><td>MINPD</td><td>Return Minimum Packed Double-Precision Floating-Point Values</td></tr><tr><td>MINPS</td><td>Return Minimum Packed Single-Precision Floating-Point Values</td></tr><tr><td>MINSD</td><td>Return Minimum Scalar Double-Precision Floating-Point Value</td></tr><tr><td>MINSS</td><td>Return Minimum Scalar Single-Precision Floating-Point Value</td></tr><tr><td>MONITOR</td><td>Setup Monitor Address</td></tr><tr><td>MOV</td><td>Move</td></tr><tr><td>MOV</td><td>Move to/from Control Registers</td></tr><tr><td>MOV</td><td>Move to/from Debug Registers</td></tr><tr><td>MOVAPD</td><td>Move Aligned Packed Double-Precision Floating-Point Values</td></tr><tr><td>MOVAPS</td><td>Move Aligned Packed Single-Precision Floating-Point Values</td></tr><tr><td>MOVD</td><td>Move Doubleword</td></tr><tr><td>MOVDDUP</td><td>Move One Double-FP and Duplicate</td></tr><tr><td>MOVDQA</td><td>Move Aligned Double Quadword</td></tr><tr><td>MOVDQU</td><td>Move Unaligned Double Quadword</td></tr><tr><td>MOVDQ2Q</td><td>Move Quadword from XMM to MMX Technology Register</td></tr><tr><td>MOVHLPS</td><td>Move Packed Single-Precision Floating-Point Values High to Low</td></tr><tr><td>MOVHPD</td><td>Move High Packed Double-Precision Floating-Point Value</td></tr><tr><td>MOVHPS</td><td>Move High Packed Single-Precision Floating-Point Values</td></tr><tr><td>MOVLHPS</td><td>Move Packed Single-Precision Floating-Point Values Low to High</td></tr><tr><td>MOVLPD</td><td>Move Low Packed Double-Precision Floating-Point Value</td></tr><tr><td>MOVLPS</td><td>Move Low Packed Single-Precision Floating-Point Values</td></tr><tr><td>MOVMSKPD</td><td>Extract Packed Double-Precision Floating-Point Sign Mask</td></tr><tr><td>MOVMSKPS</td><td>Extract Packed Single-Precision Floating-Point Sign Mask</td></tr><tr><td>MOVNTDQ</td><td>Store Double Quadword Using Non-Temporal Hint</td></tr><tr><td>MOVNTI</td><td>Store Doubleword Using Non-Temporal Hint</td></tr><tr><td>MOVNTPD</td><td>Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint</td></tr><tr><td>MOVNTPS</td><td>Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint</td></tr><tr><td>MOVNTQ</td><td>Store of Quadword Using Non-Temporal Hint</td></tr><tr><td>MOVSHDUP</td><td>Move Packed Single-FP High and Duplicate</td></tr><tr><td>MOVSLDUP</td><td>Move Packed Single-FP Low and Duplicate</td></tr><tr><td>MOVQ</td><td>Move Quadword</td></tr><tr><td>MOVQ2DQ</td><td>Move Quadword from MMX Technology to XMM Register</td></tr><tr><td>MOVS/MOVSB/MOVSW/MOVSD</td><td>Move Data from String to String</td></tr><tr><td>MOVSD</td><td>Move Scalar Double-Precision Floating-Point Value</td></tr><tr><td>MOVSS</td><td>Move Scalar Single-Precision Floating-Point Values</td></tr><tr><td>MOVSX</td><td>Move with Sign-Extension</td></tr><tr><td>MOVUPD</td><td>Move Unaligned Packed Double-Precision Floating- Point Values</td></tr><tr><td>MOVUPS</td><td>Move Unaligned Packed Single-Precision Floating- Point Values</td></tr><tr><td>MOVZX</td><td>Move with Zero-Extend</td></tr><tr><td>MUL</td><td>Unsigned Multiply</td></tr><tr><td>MULPD</td><td>Multiply Packed Double-Precision Floating-Point Values</td></tr><tr><td>MULPS</td><td>Multiply Packed Single-Precision Floating-Point Values</td></tr><tr><td>MULSD</td><td>Multiply Scalar Double-Precision Floating-Point Values</td></tr><tr><td>MULSS</td><td>Multiply Scalar Single-Precision Floating-Point Values</td></tr><tr><td>MWAIT</td><td>Monitor Wait</td></tr><tr><td>NEG</td><td>Two’s Complement Negation</td></tr><tr><td>NOP</td><td>No Operation</td></tr><tr><td>NOT</td><td>One’s Complement Negation</td></tr><tr><td>OR</td><td>Logical Inclusive OR</td></tr><tr><td>ORPD</td><td>Bitwise Logical OR of Double-Precision Floating-Point Values</td></tr><tr><td>ORPS</td><td>Bitwise Logical OR of Single-Precision Floating-Point Values</td></tr><tr><td>OUT</td><td>Output to Port</td></tr><tr><td>OUTS/OUTSB/OUTSW/OUTSD</td><td>Output String to Port</td></tr><tr><td>PACKSSWB/PACKSSDW</td><td>Pack with Signed Saturation</td></tr><tr><td>PACKUSWB</td><td>Pack with Unsigned Saturation</td></tr><tr><td>PADDB/PADDW/PADDD</td><td>Add Packed Integers</td></tr><tr><td>PADDQ</td><td>Add Packed Quadword Integers</td></tr><tr><td>PADDSB/PADDSW</td><td>Add Packed Signed Integers with Signed Saturation</td></tr><tr><td>PADDUSB/PADDUSW</td><td>Add Packed Unsigned Integers with Unsigned Saturation</td></tr><tr><td>PAND</td><td>Logical AND</td></tr><tr><td>PANDN</td><td>Logical AND NOT</td></tr><tr><td>PAUSE</td><td>Spin Loop Hint</td></tr><tr><td>PAVGB/PAVGW</td><td>Average Packed Integers</td></tr><tr><td>PCMPEQB/PCMPEQW/PCMPEQD</td><td>Compare Packed Data for Equal</td></tr><tr><td>PCMPGTB/PCMPGTW/PCMPGTD</td><td>Compare Packed Signed Integers for Greater Than</td></tr><tr><td>PEXTRW</td><td>Extract Word</td></tr><tr><td>PINSRW</td><td>Insert Word</td></tr><tr><td>PMADDWD</td><td>Multiply and Add Packed Integers</td></tr><tr><td>PMAXSW</td><td>Maximum of Packed Signed Word Integers</td></tr><tr><td>PMAXUB</td><td>Maximum of Packed Unsigned Byte Integers</td></tr><tr><td>PMINSW</td><td>Minimum of Packed Signed Word Integers</td></tr><tr><td>PMINUB</td><td>Minimum of Packed Unsigned Byte Integers</td></tr><tr><td>PMOVMSKB</td><td>Move Byte Mask</td></tr><tr><td>PMULHUW</td><td>Multiply Packed Unsigned Integers and Store High Result</td></tr><tr><td>PMULHW</td><td>Multiply Packed Signed Integers and Store High Result</td></tr><tr><td>PMULLW</td><td>Multiply Packed Signed Integers and Store Low Result</td></tr><tr><td>PMULUDQ</td><td>Multiply Packed Unsigned Doubleword Integers</td></tr><tr><td>POP</td><td>Pop a Value from the Stack</td></tr><tr><td>POPA/POPAD</td><td>Pop All General-Purpose Registers</td></tr><tr><td>POPF/POPFD</td><td>Pop Stack into EFLAGS Register</td></tr><tr><td>POR</td><td>Bitwise Logical OR</td></tr><tr><td>PREFETCHh</td><td>Prefetch Data Into Caches</td></tr><tr><td>PSADBW</td><td>Compute Sum of Absolute Differences</td></tr><tr><td>PSHUFD</td><td>Shuffle Packed Doublewords</td></tr><tr><td>PSHUFHW</td><td>Shuffle Packed High Words</td></tr><tr><td>PSHUFLW</td><td>Shuffle Packed Low Words</td></tr><tr><td>PSHUFW</td><td>Shuffle Packed Words</td></tr><tr><td>PSLLDQ</td><td>Shift Double Quadword Left Logical</td></tr><tr><td>PSLLW/PSLLD/PSLLQ</td><td>Shift Packed Data Left Logical</td></tr><tr><td>PSRAW/PSRAD</td><td>Shift Packed Data Right Arithmetic</td></tr><tr><td>PSRLDQ</td><td>Shift Double Quadword Right Logical</td></tr><tr><td>PSRLW/PSRLD/PSRLQ</td><td>Shift Packed Data Right Logical</td></tr><tr><td>PSUBB/PSUBW/PSUBD</td><td>Subtract Packed Integers</td></tr><tr><td>PSUBQ</td><td>Subtract Packed Quadword Integers</td></tr><tr><td>PSUBSB/PSUBSW</td><td>Subtract Packed Signed Integers with Signed Saturation</td></tr><tr><td>PSUBUSB/PSUBUSW</td><td>Subtract Packed Unsigned Integers with Unsigned Saturation</td></tr><tr><td>PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ</td><td>Unpack High Data</td></tr><tr><td>PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ</td><td>Unpack Low Data</td></tr><tr><td>PUSH</td><td>Push Word or Doubleword Onto the Stack</td></tr><tr><td>PUSHA/PUSHAD</td><td>Push All General-Purpose Registers</td></tr><tr><td>PUSHF/PUSHFD</td><td>Push EFLAGS Register onto the Stack</td></tr><tr><td>PXOR</td><td>Logical Exclusive OR</td></tr><tr><td>RCL/RCR/ROL/ROR</td><td>Rotate</td></tr><tr><td>RCPPS</td><td>Compute Reciprocals of Packed Single-Precision Floating-Point Values</td></tr><tr><td>RCPSS</td><td>Compute Reciprocal of Scalar Single-Precision Floating- Point Values</td></tr><tr><td>RDMSR</td><td>Read from Model Specific Register</td></tr><tr><td>RDPMC</td><td>Read Performance-Monitoring Counters</td></tr><tr><td>RDTSC</td><td>Read Time-Stamp Counter</td></tr><tr><td>REP/REPE/REPZ/REPNE/REPNZ</td><td>Repeat String Operation Prefix</td></tr><tr><td>RET</td><td>Return from Procedure</td></tr><tr><td>RSM</td><td>Resume from System Management Mode</td></tr><tr><td>RSQRTPS</td><td>Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values</td></tr><tr><td>RSQRTSS</td><td>Compute Reciprocal of Square Root of Scalar Single- Precision Floating-Point Value</td></tr><tr><td>SAHF</td><td>Store AH into Flags</td></tr><tr><td>SAL/SAR/SHL/SHR</td><td>Shift</td></tr><tr><td>SBB</td><td>Integer Subtraction with Borrow</td></tr><tr><td>SCAS/SCASB/SCASW/SCASD</td><td>Scan String</td></tr><tr><td>SETcc</td><td>Set Byte on Condition</td></tr><tr><td>SFENCE</td><td>Store Fence</td></tr><tr><td>SGDT</td><td>Store Global Descriptor Table Register</td></tr><tr><td>SHLD</td><td>Double Precision Shift Left</td></tr><tr><td>SHRD</td><td>Double Precision Shift Right</td></tr><tr><td>SHUFPD</td><td>Shuffle Packed Double-Precision Floating-Point Values</td></tr><tr><td>SHUFPS</td><td>Shuffle Packed Single-Precision Floating-Point Values</td></tr><tr><td>SIDT</td><td>Store Interrupt Descriptor Table Register</td></tr><tr><td>SLDT</td><td>Store Local Descriptor Table Register</td></tr><tr><td>SMSW</td><td>Store Machine Status Word</td></tr><tr><td>SQRTPD</td><td>Compute Square Roots of Packed Double-Precision Floating-Point Values</td></tr><tr><td>SQRTPS</td><td>Compute Square Roots of Packed Single-Precision Floating-Point Values</td></tr><tr><td>SQRTSD</td><td>Compute Square Root of Scalar Double-Precision Floating-Point Value</td></tr><tr><td>SQRTSS</td><td>Compute Square Root of Scalar Single-Precision Floating-Point Value</td></tr><tr><td>STC</td><td>Set Carry Flag</td></tr><tr><td>STD</td><td>Set Direction Flag</td></tr><tr><td>STI</td><td>Set Interrupt Flag</td></tr><tr><td>STMXCSR</td><td>Store MXCSR Register State</td></tr><tr><td>STOS/STOSB/STOSW/STOSD</td><td>Store String</td></tr><tr><td>STR</td><td>Store Task Register</td></tr><tr><td>SUB</td><td>Subtract</td></tr><tr><td>SUBPD</td><td>Subtract Packed Double-Precision Floating-Point Values</td></tr><tr><td>SUBPS</td><td>Subtract Packed Single-Precision Floating-Point Values</td></tr><tr><td>SUBSD</td><td>Subtract Scalar Double-Precision Floating-Point Values</td></tr><tr><td>SUBSS</td><td>Subtract Scalar Single-Precision Floating-Point Values</td></tr><tr><td>SYSENTER</td><td>Fast System Call</td></tr><tr><td>SYSEXIT</td><td>Fast Return from Fast System Call</td></tr><tr><td>TEST</td><td>Logical Compare</td></tr><tr><td>UCOMISD</td><td>Unordered Compare Scalar Double-Precision Floating- Point Values and Set EFLAGS</td></tr><tr><td>UCOMISS</td><td>Unordered Compare Scalar Single-Precision Floating- Point Values and Set EFLAGS</td></tr><tr><td>UD2</td><td>Undefined Instruction</td></tr><tr><td>UNPCKHPD</td><td>Unpack and Interleave High Packed Double- Precision Floating-Point Values</td></tr><tr><td>UNPCKHPS</td><td>Unpack and Interleave High Packed Single-Precision Floating-Point Values</td></tr><tr><td>UNPCKLPD</td><td>Unpack and Interleave Low Packed Double-Precision Floating-Point Values</td></tr><tr><td>UNPCKLPS</td><td>Unpack and Interleave Low Packed Single-Precision Floating-Point Values</td></tr><tr><td>VERR/VERW</td><td>Verify a Segment for Reading or Writing</td></tr><tr><td>WAIT/FWAIT</td><td>Wait</td></tr><tr><td>WBINVD</td><td>Write Back and Invalidate Cache</td></tr><tr><td>WRMSR</td><td>Write to Model Specific Register</td></tr><tr><td>XADD</td><td>Exchange and Add</td></tr><tr><td>XCHG</td><td>Exchange Register/Memory with Register</td></tr><tr><td>XLAT/XLATB</td><td>Table Look-up Translation</td></tr><tr><td>XOR</td><td>Logical Exclusive OR</td></tr><tr><td>XORPD</td><td>Bitwise Logical XOR for Double-Precision Floating-Point Values</td></tr><tr><td>XORPS</td><td>Bitwise Logical XOR for Single-Precision Floating-Point Values</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;8086汇编指令集的一些简单汇总-方便review&quot;&gt;&lt;a href=&quot;#8086汇编指令集的一些简单汇总-方便review&quot; class=&quot;headerlink&quot; title=&quot;8086汇编指令集的一些简单汇总(方便review)&quot;&gt;&lt;/a&gt;8086汇编指令集的
      
    
    </summary>
    
    
      <category term="assembler" scheme="http://MBTimY.github.io/tags/assembler/"/>
    
      <category term="8086" scheme="http://MBTimY.github.io/tags/8086/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://MBTimY.github.io/2017/09/11/hello-world/"/>
    <id>http://MBTimY.github.io/2017/09/11/hello-world/</id>
    <published>2017-09-10T21:21:28.000Z</published>
    <updated>2017-09-13T15:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="first" scheme="http://MBTimY.github.io/tags/first/"/>
    
  </entry>
  
</feed>
